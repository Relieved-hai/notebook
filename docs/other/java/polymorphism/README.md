## 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作。

多态性是对象多种表现形式的体现。

<br/>
<br/>

**必要条件**

- 继承

- 重写

- 父类引用指向子类对象

<br/>

**优点**

  - 消除类型之间的耦合关系
  - 可替换性
  - 可扩充性
  - 接口性
  - 灵活性
  - 简化性

<br/>
<br/>
<br/>


## 向上转型

**向上转型**：`隐式转型、自动转型`

  - 一个父类引用指向子类实例。

  - 把一个子类对象转成一个父类对象，小类转型为大类。

  - 可以调用 **子类重写父类**、**父类派生** 的方法，无法调用子类独有方法。

  - 父类中的静态方法无法被子类重写，所以向上转型之后，只能调用父类原有的静态方法。


```java

/*
 * Animal 父类
 * Cat    子类
 */

Animal one = new Cat();

```

<br/>
<br/>
<br/>



## 向下转型

**向下转型**：`强制类型转换`

  - 子类引用指向父类对象，此处必须进行强转。

  - 可以调用子类特有的成员方法。

  - 需要满足转换条件才能进行转换，使用 `instanceof` 运算符（ `任意实例 instanceof 对应的类或者父类` 都为true ）。

```java
/*
 * one    上面转型后的实例
 * Cat    子类
 */

Cat temp = (Cat) one;

```


<br/>
<br/>
<br/>


## abstract 抽象

- **`abstract + 类`** ：抽象类

  - 通过关键字 `abstract` 修饰的类

  - 不允许实例化，可以通过向上转型，指向子类实例。

  - 类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

  - 应用场景：某个父类只是知道其子类包含怎样的方法，但无法准确知道这些子类如何实现这些方法。这样既避免了子类设计随意性，在一定程度上也避免了无意义的父类实例化。

- **`abstract + 方法`** ：抽象方法

  - 只包含一个方法名，而没有方法体。

  - 如果一个类包含抽象方法，那么该类必须是抽象类。

  - 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。


<br/>
<br/>

**小结**

- `abstract` 定义抽象类，不能直接实例化，只能被继承，可以通过向上转型完成对象实例，可以由抽象类的非抽象子类可以创建对象。

- `abstract` 定义抽象方法，不需要具体实现（不需要方法体）

- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

- 因为 `abstract` 定义的方法是需要子类中重写的，所以 `构造方法` 以及 `static（静态）`、`final（最终）`、`private（私有）` 修饰的方法不能声明为抽象方法。

- 子类当中必须重写父类中的抽象方法，除非子类也是抽象类



<br/>
<br/>
<br/>

## Interface 接口

Java 中只支持单继承，一个子类只有一个唯一的直接父类，当两个类之间满足 `A is a B`。

**Q：如何解决一个类型中需要继承多种类型特征的问题？**

**Q：以及多个不同类型具有相同特性的问题呢？**

这时就需要用到 `interface` 接口了。

<br/>

> 接口 `Interface`，在 `Java` 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 `interface` 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。

- **类** 描述对象的属性和方法。

- **接口** 则包含类要实现的方法。

- 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

- 接口无法被实例化，但是可以被实现。

- 一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。

- 另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

<br/>
<br/>
<br/>

**接口与类相似点：**

- 一个接口可以有多个方法。

- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。

- 接口的字节码文件保存在 .class 结尾的文件中。

- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

<br/>
<br/>


**接口与类的区别：**

- 接口不能用于实例化对象。

- 接口没有构造方法。

- 接口中所有的方法必须是抽象方法。

- 接口不能包含成员变量，除了 static 和 final 变量。

- 接口不是被类继承了，而是要被类实现。

- 接口支持多继承。


<br/>
<br/>

**接口特性：**

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 `public abstract`，不必使用abstract关键字（只能是 `public abstract`，其他修饰符都会报错）。

- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 `public static final` 变量，不必使用abstract关键字（并且只能是 `public`，用 `private` 修饰会报编译错误）。

- 接口中的方法都是公有的，接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

- 当类实现接口时，除了抽象类以外，都需要去实现接口中的所有抽象方法。

- 如果实现类中和接口当中存在一个同名的信息，例如 `public static final int TEMP = 值`。

  - 当在程序中，使用 `接口的引用指向实现类` 的时候，这时的 TEMP 依然是接口中定义的值。

  - 当在程序中，使用 `实现类的引用指向实现类` 的时候，这时的 TEMP 就是实现类中定义的值。

  ```java
  INet net = new SmartWatch();
  net.TEMP // -> INet 中定义的值

  SmartWatch sw = neww SmartWatch();
  sw.TEMP // -> SmartWatch 中定义的值
  ```

<br/>
<br/>
<br/>


**声明：**
```java
// Interface关键字用来声明一个接口。
[可见度] interface 接口名称 [extends 其他的接口名] {
    // 声明变量
    // 抽象方法
}
```

```java
// 接口访问修饰符： public 默认
public interface INet {
  /*
   * 接口当中抽象方法可以不写 abstract 关键字
   * 也可以不写 public，默认使用 public
   * 当类实现接口时，需要去实现接口中的所有抽象方法，否则需要将该类设置为抽象类，让它接着传下去。
   */
  public void network();

  /*
   * 接口中 默认会给常量添加 public static final
   */
  int TEMP = 20;

  /*
   * JDK1.8+
   *   default 默认方法，可以带方法体
   *   可以通过接口引用实例化的一个子类的对象进行调用
   *   可以在实现类中重写，并可以通过接口的引用调用
   */
  default public void connection() {
    System.out.println("我是接口中的默认方法");
  }

  /*
   * JDK1.8+
   *   static 静态方法也是可以带方法体的
   *   只能通过接口.进行调用
   *   不可以在实现类中重写，可以用接口名调用
   */
  static void stop() {
    System.out.println("我是接口中的静态方法");
  }
}
```

<br/>

**实现：**

当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。

类使用 `implements` 关键字实现接口。在类声明中，`Implements` 关键字放在 `class` 声明后面。

```java
...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
```

```java
public class SmartWatch implements Inet {
  public static final int TEMP = 30;

  public void network() {
    System.out.println("network");
  }

  @Override
  public void connection() {
    // 调用接口中默认的方法
    INet.super.commection();
  }
}
```

<br/>
<br/>
<br/>

## 关于多接口中重名默认方法处理的解决方案


> INet、IPhoto

当 `INet` 和 `IPhoto` 中，

- 都有 `default public void connection() {}` 默认方法时:

  - 如果不重写 `connection` 的话，程序就会报错。

- 都有属性 `x` (无论 `static`、`final` 修饰的)时：

  - 需要显示的来指定到底是访问 `INet` 还是 `IPhoto` 中的属性。

```java
public class SmartWatch implements INet, IPhoto {

  public void connection() {
    System.out.println(INet.x);
  }
}
```

<br/>
<br/>

> 父类、INet、IPhoto

当 `父类、INet、IPhoto` 中

- 都有 `public void connection() {}` 方法时:

  - 默认会调用父类中的 `connection` 方法，也可以在子类中进行重写

- 都有属性 `x` 时：

  - 必须要在子类中去定义 `x` 成员。

```java
public class SmartWatch extends ParentWatch implements INet, IPhoto {
  public int x = 66;

  public void connection() {
    System.out.println(x);
  }
}

```


<br/>
<br/>
<br/>

## 接口可继承

> 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。

在Java中，类的多继承是不合法，但接口允许多继承。

在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：

```java
public interface Hockey extends Sports, Event
```

如果，两个父接口中都有相同的默认签名，那么需要在子类中进行重写签名



<br/>
<br/>
<br/>

## 内部类

> 在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类成为内部类

内部类隐藏在外部类之内，更好的实现了信息隐藏

<br/>

- **成员内部类**

  - 内部类中最常见的就是成员内部类，也称为普通内部类。

  - 内部类在外部使用时，无法直接实例化，需要借由外部类信息才能完成实例化。获取内部类对象：

    - 方式一：`new 外部类().new 内部类()`

    - 方式二：`外部类对象.new 内部类()`

    - 方式三：`外部类对象.获取内部类方法()`

  - 内部类的访问修饰符，可以任意，但是访问范围会受到影响。

  - 内部类可以直接方位外部类的成员，如果出现同名属性，优先访问内部类中定义的。

  - 可以使用外部类.this.成员的方式，访问外部类中的同名的信息

  - 外部类访问内部类信息，需要通过内部类实例，在去访问，不能直接访问

  - 内部类编译后的.class文件命名： 外部类$内部类.class

- **静态内部类**

  -  静态内部类中，只能直接访问外部类的静态成员(属性、方法)，如果需要调用非静态成员(属性、方法)，可以通过对象实例调用

  - 静态内部类对象实例时，可以不依赖于外部类对象
  - 可以直接通过 `外部类.内部类.静态成员`，访问内部类中的静态成员
  - 当内部类属性与外部类属性同名时，默认直接访问内部类中的成员。
  - 如果需要访问外部类中的静态属性，则可以直接通过 `外部类.属性` 的方法。
  - 如果需要访问外部类中的非静态属性，则可以通过 `new 外部类().属性` 的方法。

- **方法内部类**

  - 定义在外部类方法中的内部类，也称局部内部类
  - 定义在方法内部，作用范围也在方法内，定义的局部变量只能在方法里使用
  - 和方法内部成员使用规则一样，class前面不可以添加 public private protected static
  - 内中不能包含静态成员，
  - 类中可以包含final、abstract(不推荐)

- **匿名内部类**

  - 使用场景：
    - 只用到类的一个实例
    - 类在定义后马上用到
    - 给类命名并不会导致代码逻辑的场景

  - 匿名内部类没有类型名称、实例对象名称
  - 编译后的文件命名：外部类$数字.class
  - 无法使用private public protected abstract static 修饰
  - 无法编写构造方法、可以添加构造代码块
  - 不能出现静态成员
  - 匿名内类可以实现接口，也可以继承父类，但是不可以兼得





































