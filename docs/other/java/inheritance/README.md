## 概念

继承是 `java` 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。

继承就是 **子类** 继承 **父类** 的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。


- 一种类与类之间的关系

- 使用已存在的类的定义作为基础建立新类

- 新类的定义可以增加新的属性、方法，也可以同父类的属性、方法，但是不能选择性地继承父类

- 父类（超类、基类）

- 子类（派生类）


<br/>

**继承的关系**

满足 "A is a B" 的关系就可以形成继承关系

<br/>

**继承的特性**

- 子类拥有父类非 private 的属性、方法

- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。

- 子类可以用自己的方式实现父类的方法

- Java 的继承是单继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。

- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

<br/>
<br/>
<br/>

## 继承实现

通过 `extends` 关键字

```java
// 父类
public class Animal {

}


// 子类(Cat) 继承 父类(Animal)
public class Cat extends Animal {

}

// 子类(Dog) 继承 父类(Animal)
public class Dog extends Animal {

}
```

<br/>
<br/>
<br/>

## 重载 ( Overload )

- 在同一类中

- 方法名相同，参数列表必须改变（参数个数、类型、顺序 其中一个改变即可）

- 可以改变返回类型、访问修饰符；

- 与方法的参数名无关，如果两个方法仅仅是参数名不一样，参数类型、顺序、个数没有区别的话，这是无法构成重载的。也就是说，每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

- 可以声明新的或更广的检查异常；


<br/>

```java
class Animal {
  public void sleep() {
  }

  private String sleep(String name) {
    return "";
  }

  public void sleep(String name, int month) {
  }

  public void sleep(int month, String name) {
  }

  // 这是不允许的
  // 该方面与上面的方法仅仅是参数名不一样，参数类型、顺序、个数都一样，这是无法构成重载的。
  public void sleep(int name, String month) {
  }
}
```



<br/>
<br/>
<br/>

## 重写 ( Override )

- 有继承关系的子类中
- 方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值可以允许是子类类型
- 方法的访问范围需要大于等于父类的访问修饰符
- 与 参数名 无关
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。


<br/>

```java
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}

public class TestDog{
   public static void main(String args[]){
      Animal a = new Animal(); // Animal 对象
      Animal b = new Dog(); // Dog 对象

      a.move();// 执行 Animal 类的方法
      b.move();//执行 Dog 类的方法
   }
}
```

编译运行结果
```shell
动物可以移动
狗可以跑和走
```

<br/>
<br/>

**重写与重载之间的区别**

区别点|重载方法|重写方法
:-|:-:|:-
参数列表|必须修改|一定不能修改
返回类型|可以修改|一定不能修改
异常|可以修改|可以减少或删除，一定不能抛出新的或者更广的异常
访问|可以修改|一定不能做更严格的限制（可以降低限制）

<br/>
<br/>
<br/>


## 访问修饰符

> Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- **default** (即默认，什么也不写）:

  - 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

  - 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。

  - 接口里的变量都隐式声明为 **`public static final`**

  - 而接口里的方法默认情况下访问权限为 **`public`**。

- **private** (私有访问修饰符):

  - 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

  - 私有访问修饰符是最严格的访问级别，所以被声明为 **`private`** 的方法、变量和构造方法只能被所属类访问。

  - 并且类和接口不能声明为 **`private`**。

  - 声明为私有访问类型的变量只能通过类中公共的 `getter` 方法被外部类访问。

  - **`private`** 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

- **public** (公有访问修饰符):

  - 对所有类可见。使用对象：类、接口、变量、方法

- **protected** (受保护的访问修饰符):

  - 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）（内部类除外）。

  - **子类与基类在同一包中：** 被声明为 **`protected`** 的变量、方法和构造器能被同一个包中的任何其他类访问；

  - **子类与基类不在同一包中：** 那么在子类中，子类实例可以访问其从基类继承而来的 **`protected`** 方法，而不能访问基类实例的 **`protected`** 方法。

  - 接口及接口的成员变量和成员方法不能声明为 **`protected`**


<br/>

访问修饰符|当前类|同包|子孙类(同包)|子孙类(不同包)|其他类
:-|:-:|:-:|:-:|:-:|:-
private|️✔||||
default|✔|✔|✔||
protected|✔|✔|✔|✔/✘|
public|✔|✔|✔|✔|✔|


<br/>
<br/>
<br/>


## super 关键字

在代码中，我们怎么确定这个方法是继承父类的方法，还是自己重写的方法呢？


**super**：代表父类引用

- 访问父类成员方法 super.eat()、访问父类属性 super.name、访问父类构造方法 super()。

- this 和 super 不能共存。

- 子类构造默认调用父类无参构造方法。

- 如果子类构造方法中没有显式标注，则系统默认调用父类的无参构造方法。

- 可以通过super()调用父类允许被访问的其他构造方法。

- super()调用父类指定构造方法时，必须放在子类构造方法有效代码第一行。

例
```java
// Animal 类
public class Animal {
  Animal() {}
  Animal(String name) {}
  eat() {}
}

// Dog 类
public class Dog extends Animal {
  Dog() {}

  eat() {}

  sleep() {
    super.eat(); // 这里 super 代表父类引用
    // super('name') 可以通过 super(参数，参数，...) 来调用父类允许被访问的其他构造方法，
  }
}

public class Test {
  public static void main(String[] arg) {
   Dog dog = new Dog();

   dog.eat(); // 这里的 eat 调用的是？
  }
}
```

<br/>

**this**: 当前类对象的引用

- 访问当前类的成员方法
- 访问当前类的成员属性
- 访问当前类的构造方法
- 不能再静态方法中使用

**super**: 父类对象的引用

- 访问父类的成员方法
- 访问父类的成员属性
- 访问父类的构造方法
- 不能再静态方法中使用

<br/>
<br/>
<br/>

## 继承的初始化顺序

```java
public class Animal {
  private String name = "可可";
  protected int month = 2;
  String species = "动物";
  public int temp = 15;
  private static int st1 = 1;
  public static int st2 = 2;

  static {
    System.out.printlln('我是父类静态构造代码块');
  }

  {
    System.out.printlln('我是父类构造代码块');
  }

  // 父类的构造不允许被继承、不允许被重写
  public Animal() {
    System.out.printlln('我是父类无参构造方法');
  }
}

public class Cat extends Animal {
  private double weiget;
  public static int st3 = 3;

  static {
    System.out.printlln('我是子类静态构造代码块');
  }

  {
    System.out.printlln('我是子类构造代码块');
  }

  public Animal() {
    System.out.printlln('我是子类无参构造方法');
  }
}

public class Test {
  public static void main(String[] arg) {
   Cat cat = new Cat();
  }
}
```

<br/>
<br/>

- 1、new 类

- 2、**父类** 静态成员初始化、赋值

- 3、**父类** 静态代码块执行

- 4、**子类** 静态成员初始化、赋值

- 5、**子类** 静态代码块执行

- 6、在进行 **new** 的实例化

- 7、上面的代码中，是实例化了一个 **Cat**;

  - 这时就会进入 **Cat** 的无参构造方法中。

  - 这时发现 **Cat** 有个父类 **Animal**，这时就会进入 **Animal** 的无参构造方法中。

  - 这时发现 **Animal** 又有个父类 **Object**，这时就会进入 **Object** 中（每一个类都是 **Object** 的子类）。

  - 然后会逐层返回到 **Cat** 进行实例操作，这时，这个对象就已经产生了，此时类中的相关信息都是默认值。

- 8、回到**父类**中，去完成对父类属性的赋值操作

- 9、执行 **父类** 的构造代码块

- 10、执行 **父类** 的构造方法

- 11、**子类** 的属性没有赋值操作，跳过

- 12、执行 **子类** 的构造代码块

- 13、执行 **子类** 的构造方法

- 14、最后，回到 **new** 调用处。


<br/>
<br/>
<br/>

**在满足继承条件的情况下，子类的初始化顺序**


首先，在我们执行程序的时候，会先完成类的加载，在加载的过程当中。

- 优先加载父类的静态成员

- 然后加载子类的静态成员

- 然后在进行子类对象实例化的过程当中。

- 它会逐层的先去完成父类对象的加载（属性（赋值）、构造代码块、构造方法）

- 然后才会去完成子类对象的加载

:::tip
访问修饰符不影响成员加载顺序，跟书写位置有关。谁在前，就先执行谁。
:::

<br/>
<br/>
<br/>

## Object 类

- `Object` 类是所有类的父类。

- 一个类没有使用 `extends` 关键字明确标识继承关系，则默认继承 `Object` 类（ 包括数组 ）。

- Java 中的每个类都可以使用 `Object` 中定义的方法。

<br/>
<br/>
<br/>

## final

> final 表示"最后的、最终的"含义，变量一旦赋值后，不能被重新赋值。

使用 final 修饰符可以提高性能，但会降低可扩展性。

- **`final + 类`**

  - `final` 类不能被继承，没有类能够继承 final 类的任何特性。

- **`final + 属性`**

  - **方法内部的局部变量**：在使用之前被初始化赋值即可。

  - **类中成员属性**：只能在定义时、或者构造代码块、构造方法中进行初始化赋值。

  - **基本数据类型变量**：初始赋值之后不能更改。

  - **引用类型的变量**：初始化之后不能再指向另一个对象，但指向的对象的内容是可变的。

  - `final` 修饰符通常和 `static` 修饰符一起使用来创建类常量。

- **`final + 方法`**

  - 父类中的 `final` 方法可以被子类继承，但是不能被子类重写。

  - 声明 `final` 方法的主要目的是防止该方法的内容被修改。

  - 不能修饰构造方法


<br/>
<br/>
<br/>

## 注解

- JDK1.5 版本引入的一个特性

- 可以声明在包、类、属性、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释


注解分类

- 按照运行机制

  - **源码注解**：注解只在源码中存在，编译成 .class 文件就不存在了。

  - **编译时注解**：注释在源码和 .class 文件中都存在

  - **运行时注解**：在运行阶段还起作用，甚至会影响运行逻辑的注解

- 按照来源分

  - 来自 JDK 的注解

  - 来自第三方的注解

  - 我们自己定义的注解


元注解（主要用来对注解进行注释的）



















