Java 是一种面向对象的语言

## 什么是对象？

- 万物皆对象、可以理解现实存在的客观事物都是对象。

- 对象：用来描述客观事物的一个实体，由一组属性和方法构成。

<br/>
<br/>
<br/>

## 什么是面向对象？

从字面上理解，就是与对象面对面，关注对象。从计算机的角度而言，可以理解为：是关注现实存在的事物的各方面的信息，从对象的角度出发，根据事物的特征进行程序设计。

- 人关注对象

- 人关注事物信息

<br/>
<br/>
<br/>

## 类和对象
- 类

  - 所谓的类，是一个抽象的概念。

  - 是一种类型的描述，它用来确定将会拥有的特征（ 属性 ）和行为（ 方法 ）（ `描述了一个模板，它限定了一种类型当中应该有什么，以及能做什么` ）。

  - 类是对象的类型。

  - 是具有相同属性和方法的一组对象的集合。

<br/>

**定义类**

```java
public class 类名 {
  // 定义属性部分
  [访问修饰符] 数据类型 属性名；

  // 定义方法部分
  [访问修饰符] 返回类型 方法名(参数) {}
}
```

<br/>

- 对象

  - 用来描述客观事物的一个实体，由一个类实例产生的具体体现（ `真正的看得见，摸得着，能干活的具体的实物` ）。

  - 对象是类的实例表现。

  - 可以认为，对象是特定类型的数据。


<br/>

**创建并引用对象**

```java
类名 对象名 = new 构造方法();
对象名.属性名
对象名.方法名()
```

<br/>

:::tip
在类的定义过程中。<br/>

普通方法中定义的局部变量不赋值是不能使用的。<br/>

而 Java 中类的成员属性，默认是有初始值的，是可以直接使用的。
:::


<br/>

基本类型|默认值
:-|:-
byte|0
short|0
int|0
long|0L
float|0.0f
double|0.0d
char|'\u0000'
boolean|false

**引用类型** 对象的初始值 `null`

<br/>


在实际开发中， 根据程序需求 -> 设计类 -> 实例化对象 -> 完成具体的程序逻辑

<br/>
<br/>
<br/>

## 属性和方法

- 属性：对象具有的各种静态特征

  - "对象有什么"

- 方法：对象具有的各种动态行为

  - "对象能做什么"

<br/>
<br/>
<br/>

## 实例化对象

```java
/**
 * 定义了一个类
 */
public class Cat {
  String name;

  public void run() {
    System.out.printIn("");
  }
}

public class CarTest {
  public static void main(String[] args) {
     Cat cc = new Cat();
     cc.run();
  }
}
```

<br/>
<br/>

#### 实例化对象的过程：

- 1、声明对象 Cat cc。

  - 在 **栈** 中开辟一个名为 `cc` 的对象，值为 `null` 的内存空间。

- 2、用 `new` 关键字，去实例化对象 `new Cat()`。

  - 在 **堆** 中开辟一个新的空间进行实例化操作。

在两个不同的空间中进行的，通过 `=` 赋值，把 **堆** 中的内存地址指向 **栈** 中的对象，让两块内存进行关联。


<br/>
<br/>
<br/>

## 构造方法

> 也称：构造函数、构造器

<br/>

:::tip
是面向对象编程当中的一个重要的概念，我们经常会使用构造方法来完成对象初始化的相关设置。
:::

<br/>

> 它也是 new 关键字的好搭档，它在类外被调用的时候，必须配合 new 关键字，是不能直接被对象单独调用的。

<br/>


#### 构造方法

- 构造方法必须与类同名，且无返回值。

- 可以指定参数。

- 只会在对象实例化（ `new` ）的时候调用。

- 当没有指定构造方法时，系统会自动添加无参的构造方法，反之，则不会添加。

- 一个类可以有多个构造方法。

- 构造方法是不能被类里的普通方法调用的。


<br/>

`语句格式：`

```java
public class 类名 {
  // 构造方法名必须和类名一样
  public 构造方法名() {
  }
}
```

<br/>
<br/>
<br/>

## this 关键字的用法

> this 在类中就是代表当前对象，可以通过 this 关键字完成当前对象的成员属性、成员方法和构造方法的调用。

<br/>

何时用 this ?

当在定义类中的方法时，如果需要调用该类对象，就可以用 this 来表示这个对象。也就是说，但凡在本类功能内部使用到了本类对象，都用 this 表示。至于代表哪个对象，就看其所在功能被哪个对象调用，这样就知道谁在参与运算。


```java
package com.test.test;

public class User {
  private String name;

  User() {
    System.out.printIn("我是无参构造方法");
  }

  User(String name) {
    // 用于构造方法间的相互调用，而且只能放在构造方法的第一行。
    // 表示调用本类中的无参构造方法。
    this();

    // 如果在构造方法里使用（ name = name ）,那么其是赋值给他本身，而不是赋值给类里面的属性 name。
    // this.name = zs.name
    this.name = name;

    // 这里写着 zs，是因为 zs 这个对象在调用这个函数，一句话，谁调用它就在代表谁。
    // 其实就等于 zs.method
    this.method();
  }

  // 不推荐该写法
  // public void Cat() {
  //  System.out.printIn("我只是一个普通方法，名字也叫 Cat");
  //}

  public void method() {
    System.out.printIn("method 方法");
  }

  public static void main() {
    User zs = new User("张三");
    System.out.printIn(zs.name);
  }
}
```

<br/>

**运行效果：**

```shell
我是无参构造方法
method 方法
张三
```

<br/>
<br/>
<br/>

## 单一职责原则

单一职责原则（ `SRP`：`Single responsibility principle` ）又称单一功能原则。

面向对象五个基本原则 `SOLID`

- `SRP` 单一责任原则（ `Single-Resposibility Principle` ）

- `OCP` 开放封闭原则（ `Open-Closed principle` ）

- `LSP` 里氏替换原则（ `Liskov-Substituion Principle` ）

- `ISP` 接口分离原则（ `Interface-Segregation Principle` ）

- `DIP` 依赖倒置原则（ `Dependecy-Inversion Principle` ）

<br/>

>它规定一个类应该只有一个发生变化的原因。该原则由 `罗伯特·C·马丁（Robert C. Martin`）于`《敏捷软件开发：原则、模式和实践》`一书中给出的。马丁表示此原则是基于 `汤姆·狄马克(Tom DeMarco)` 和 `Meilir Page-Jones` 的著作中的内聚性原则发展出的。所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

<br/>

之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：

- T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。

- 解决办法：遵守单一职责原则，将不同的职责封装到不同的类或模块中。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这
样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。










