在某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。

对应下面的递归就会无限制的循环下去，直到超出调用堆栈的实际大小，这个是浏览器定义的。

```js
function foo() {
  foo()
}

foo()
```

![超出堆栈](error.png)

<br/>
<br/>
<br/>


## 栈数据结构

栈的结构就是后进先出 **（ LIFO ）** 。文中使用乒乓球盒子的结构来解释。

处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球却出来，让乒乓球1处于盒子顶层。

![栈数据结构](memory.jpg)

<br/>
<br/>
<br/>

## 堆数据结构

堆数据结构是一种树状结构，它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的 `key-value` 可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

<br/>
<br/>
<br/>

## 队列

队列是一种先进先出 **（ FIFO ）** 的数据结构，这是事件循环 **（Event Loop）** 的基础结构。

![队列](alignment.jpg)

<br/>
<br/>
<br/>

## 变量的存放

首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢？ **堆？** **栈？**

1. **基本类型：** 
    - 保存在 **栈** 内存中。
    - 因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
    - 基本类型一共有6种，Undefined、Null、Boolean、Number、String 和 Symbol。

2. **引用类型：**
    
    - 保存在 **堆** 内存中。
    - 因为这种值的大小不固定，因此不能把它们保存到栈内存中。
    - 但内存地址大小是固定的。因此保存在堆内存中。
    - 在栈内存中存放的只是该对象的访问地址。
    - 当查询引用类型的变量时，先从 **栈中读取内存地址**，然后再通过地址 **找到堆中的值**。对于这种，我们把它叫做按 **引用访问**。

<br/>

![堆栈](stack.png)

<br/>

在计算机的数据结构中，栈比堆的运行速度快，Object 是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删查改。将它们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象在进行操作。所以查找引用类型值的时候先去 **栈** 查找，再去 **堆** 查找。

<br/>
<br/>
<br/>

## 闭包

闭包中的变量并不保存在栈内存中，而是存在 **堆内存** 中，这也就解释了函数之后为什么闭包还能引用到函数内的变量。

> **闭包** 的简单定义： 在一个函数里再定义一个内部函数，并且这个内部函数用到了外边函数的变量或参数，并且外部函数的返回值是内函数的引用，或直接或间接的立即执行内部函数。

<br/>
<br/>
<br/>

## 例子

例子1：
```js
var a = 20;
var b = a;
b = 30;

// a的值？
```

例子2：
```js
var a = { name: '前端开发' }
var b = a
b.name = 'web'

// b.name的值？
```

例子3：
```js
var a = { name: '前端开发' }
var b = a
a = null

// b的值？
```

分别是： `20` `web` `前端开发`

- 例子1： a, b 都是基本类型，它们的值是存储在栈中的，a, b分别有各自独立的栈空间，所以修改了 b 的值以后，a 的值并不会发生变化。

- 例子2： a, b 都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的赋值会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改 b.name 的值后，相应的 a.name 也就发生了改变。

- 例子3： 首先要说明的是 null 是基本类型， a = null 之后，只是把 a 存储在栈内存中地址改成了基本类型 null，并不会影响堆内存中的对象，所以 b 的值不受影响。

<br/>
<br/>
<br/>

## 内存空间管理

JavaScript 的内存声明周期是

- 1. 分配你所需要的内存
- 2. 使用分配到的内存（读、写）
- 3. 不需要时将其释放、归还

JavaScript 有自动垃圾收集机制，最常用的是通过 **标记清除** 的算法来找到哪些对象不再继续使用的，使用 a = null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。

在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在开发中，需要尽量避免使用全局变量。

<br/>
<br/>
<br/>

## 思考
```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// ?
b.x     // ?
```

答案是 `undefined` `{ n: 2 }`

1. **优先级** `.` 的优先级高于 `=`
    - 所以先执行 `a.x`
    
    - 堆内存中的 `{n: 1}` 就会变成 `{n: 1, x: undefined}`
    
    - 改变之后相应的 `b.x` 也变化了，因为指向的是同一个对象。

2. **赋值操作是 从右到左** 
    - 所以先执行 `a = {n: 2}`，`a` 的引用就被改变了
    
    - 然后这个返回值又赋值给了 `a.x`
    
    - **需要注意**的是这时候 `a.x` 是第一步中 `{n: 1, x: undefined}` 的那个对象，其实就是 `b.x`，相当于 `b.x = {n: 2}`

![思考](memory_space.png)

<br/>
<br/>
<br/>

参考
> [前端基础进阶（一）：内存空间详细图解](https://www.jianshu.com/p/996671d4dcc4)
>
>[解读 JavaScript 之引擎、运行时和堆栈调用](https://www.oschina.net/translate/how-does-javascript-actually-work-part-1)
>
>[JavaScript变量——栈内存or堆内存](https://blog.csdn.net/xdd19910505/article/details/41900693)
>
>[连等赋值](https://segmentfault.com/a/1190000004224719)
>
>[运算符优先级
 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
