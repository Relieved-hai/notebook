<auth-auth />

SQL VS NOSQL

## 关系型数据库的特点

- 数据结构化存储在二维表中。

- 支持事务的原子性 `A`，一致性 `C`，隔离性 `I`，持久性 `D` 特性。

- 支持使用 SQL 语言对存储在其中的数据进行操作。

<br/>
<br/>
<br/>

## 关系型数据库的使用场景

- 数据之间存在着一定关系，需要关联查询数据的场景。

- 需要事务支持的业务场景。

- 需要使用 SQL 语言灵活操作数据的场景。

<br/>
<br/>
<br/>

## 非关系型数据库的特点

- 存储结构灵活，没有固定的结构

- 对事务的支持比较弱，但对数据的并发处理性能高。

- 大多不使用 SQL 语言操作数据。


<br/>
<br/>
<br/>

## 非关系型数据库的使用场景

- 数据结构不固定的场景。

- 对事务要求不高，但读写并发比较大的场景。

- 对数据的处理操作比较简单的场景。


<br/>
<br/>
<br/>

## 关系型数据库选型原则

- 数据库使用的广泛性。

- 数控库的可扩展性。

  - 支持基于二进制日志的逻辑复制

  - 存在多种第三方数据库中间层，支持读写分离及分库分表。

- 数据库的安全性和稳定性。

  - MySQL 主从复制集群可达到 99% 的可用性。

  - 配合主从复制高可用架构可以达到99.99%的可用性。

  - 支持对存储在 MySQL 的数据进行分级安全控制。

- 数据库所支持的系统。

- 数据库的使用成本。


<br/>
<br/>
<br/>

## 数据库结构设计

业务分析 -> 逻辑设计 -> 数据类型 -> 对象命名 -> 建立库表

<br/>
<br/>
<br/>

[慕课免费课程分析](https://www.imooc.com/course/list)

<br/>

- **课程的属性**

  - 主标题、副标题、方向、分类、难度、最新、最热、时长、简介、人数、需知、收获、讲师名、讲师职位、课程图片、综合评分、内容是否实用、是否简洁易懂、逻辑是否清晰

- **课程列表的属性**

  - 章节名、小节名、说明、小节时长、章节URL、视频格式

- **讲师的属性**

  - 讲师昵称、密码、性别、省、市、职位、经验、积分、关注人数、粉丝人数

- **问答评论属性**

  - 类型、标题、内容、关联章节、浏览量、发布时间、用户昵称

- **笔记的属性**

  - 用户昵称、关联章节。笔记标题、笔记内容、发布时间

- **用户的属性**

  - 用户昵称、密码、性别、省、市、职位、说明、积分、关注人数、粉丝人数

- **评价的属性**

  - 用户、课程主标题、内容、综合评分、内容实用、简洁易懂、逻辑清晰、发布时间

<br/>
<br/>
<br/>

> 确定好后，那么对于一个对象。我们最容易想到存储方式是什么样的呢？

**宽表模式**

就是把一个对象的所有属性全存储在一个表中，表中字段比较多，包含的维度层次比较多，造成冗余也比较多，毁范式设计，但是利于取数统计。

<br/>
<br/>
<br/>

**该表存在的问题**

> 课程表
>
> | 主标题 | 副标题   | 方向 | 分类 |  难度 | 讲师名 | 讲师职位 |综合评分 |
> | ----- | --------- | ----------- | ------- |------- |------- |------- |------- |
> | 主标题1 | 副标题1 | 数据库 | MySQL | 中级 | hai | 高级 DBA | 10 |
> | 主标题2 | 副标题2 | 数据库 | MySQL | 中级 | hai | 高级 DBA | 10 |
> | 主标题3 | 副标题3 | 数据库 | MySQL | 中级 | hai | 高级 DBA | 10 |
> | 主标题4 | 副标题4 | 数据库 | MySQL | 中级 | hai | 高级 DBA | 10 |
>

- 数据冗余：相同的数据在一个表中出现了多次。

  - 可以看出每一行都存在相同的数据，例如讲师名、讲师职位，如果一个讲师有多门课程，那么这条相同的信息将会出现多次。

  - 这在一方面会增加对象占用的存储空间、另一方面，在进行数据的维护时，我们就不得不对数据进行多次的维护。如果讲师职位发生变化，那是不是要对所以讲师的数据进行更新，否则将会导致相同讲师的信息不一致

- 数据更新异常：修改一行中某列的值时，同时修改了多行数据。

  - 当我们想修改一行数据的某一列的值时，不得不同时修改了多行的数据。

  - 如果，我们只想修改第一条中的讲师信息时，我们想将其职位修改成 `MySQL 架构师`，那么可以使用 `UPDATE 课程表 SET 讲师职位 = 'MySQL 架构师' WHERE 讲师名 = 'hai'` SQL 语句来修改。那么这条语句将影响多条数据。但是你会想，这是这条 SQL 有问题，我们在加一个条件，来限制它 `UPDATE 课程表 SET 讲师职位 = 'MySQL 架构师' WHERE 讲师名 = 'hai' AND 主标题 = '主标题1'`。也就是说，我们可以将主标题作为主键，来当做该行的唯一标识来使用，通过主键来更新，这样虽然可以修改正常，但是会导致讲师的信息不一致。在宽表中引入 `主键` 之后，又会导致数据插入问题。

- 数据插入异常：部分数据由于缺失主键信息而无法写入表中。

  - 我们知道主键一定是 `非空且唯一的`

  - 这个时候，我们想把 `后端开发` 这个技术方向，维护到这个表中，那么由于并没有表中的其他信息，我们会使用 `INSERT INTO 课程表(方向) VALUES ('后端开发')` 来往表中增加这条数据，假设，我们并没有后端开发所匹配的课程，那么由于这个表的主键是课程的主标题，那么这是主键就是空的，那么就违反了主键 `非空且唯一的` 的约束。因此无法维护该条数据。

- 数据删除异常：删除某一数据时不得不删除(必须要删除)另一数据。

  - 假如，我们想在基础方向中，删除掉 `数据库` 这一方向，那么会使用 `DELETE FROM 课程表 WHERE 方向 = '数据库'`，当执行后，它是删除了，但也将整条数据都给删除了。

<br/>
<br/>
<br/>

**应用场景**

- 配合列存储的数据报表应用

<br/>
<br/>
<br/>

## 数据库设计范式

- 第一范式：表中的所有字段都是不可在分的。符合第一范式的表，都是二维表。

- 第二范式：表中必须存在业务主键，并且非主键依赖于全部业务主键，不能出现只依赖于一部分列的情况。

  - 业务主键（自然主键）：唯一可以标识出每一行业务数据的列、或是列的组合，在数据库表中把具有业务逻辑含义的字段作为主键，称为 “自然主键(Natural Key)”。例如：每个人都有一个唯一标识自己身份的身份证号码。

<br/>

> 笔记表
>
> | 用户 | 章节   | 标题 | 内容 | 用户积分 | 时间 |
> | ----- | --------- | ----------- | ------- |------- |------- |
> | 张三 | 1-1 | 笔记1 | 测试笔记 | 300 | 2020-02-02 |
>

如果，我们用用户列来作为这个表的业务主键，显然是不可行的，因为一个用户是有多个笔记的。所以用户无法唯一标识出表中的记录。

同理，章节可以有多个不同的用户，来写笔记，标题也是如此。所以无法使用单一的某一列作为主键。

那么，只能用 用户、章节、标题 来组合成一个复合主键，也就是列的组合。

在看看剩余的列，是否与这个复合主键的全部列都存在依赖关系呢？内容列和时间列是没有问题的，但是用户积分列，实际上只和用户列存在依赖关系。

所以这个表就暂不符合第二范式的要求。所以，只要把不存在全部依赖关系的表提出来，单独放在一个表中。

> 笔记表
>
> | 用户 | 章节   | 标题 | 内容 |  时间 |
> | ----- | --------- | ----------- | ------- |------- |
> | 张三 | 1-1 | 笔记1 | 测试笔记 | 2020-02-02 |
>
> 用户表
>
> | 用户 | 积分  | ... |
> | ----- | ------- | ----- |
> | 张三 | 300 | ... |
>

如果表的业务主键只有一个列来组成的，那么这个表天生就符合第二范式的要求，如果是多个列，就要区别对待，看看是不是符合第二范式的要求

- 第三范式：表中的非主键列之间不能互相依赖

> 课程表
>
> | 主标题 (PK) | 副标题  | 方向 |分类 |难度 |讲师名 |讲师职位 |综合评分 |
> | ----- | ------- | ----- |----- |----- |----- |----- |----- |
> | 课程一 | 课程一描述 | 数据库 | MYSQL | 初级 | hai | 高级DBA | 10 |
> | 课程二 | 课程二描述 | 数据库 | MYSQL | 初级 | hai | 高级DBA | 10 |
>

可以看到，这个表只有一个业务主键列，毕竟不可能存在同一个名的课程，这就符合第二范式的要求，符合第二范式的表也不能避免数据冗余的问题。

可以看到 副标题、方向、分类、难度、讲师、综合评分 都依赖于主标题，之间也不相互依赖，但是 讲师职位列 却依赖 讲师名，而于主标题并无直接依赖关系。同理，只要把不存在直接依赖关系的 列 提出来，放到单独的表中。

> 课程表
>
> | 主标题 (PK) | 副标题  | 方向 |分类 |难度 |讲师名 | 综合评分 |
> | ----- | ------- | ----- |----- |----- |----- |----- |
> | 课程一 | 课程一描述 | 数据库 | MYSQL | 初级 | hai | 10 |
> | 课程二 | 课程二描述 | 数据库 | MYSQL | 初级 | hai | 10 |
>
> 讲师表
>
> | 讲师名 | 职位  |
> | ----- | ------- |
> | hai | 高级 DBA |
>
>

<br/>
<br/>
<br/>

## 例子

### 逻辑设计

<br/>

> 课程对象

- 课程的属性：{ 主标题、副标题、方向、分类、难度、最新、最热、时长、简介、人数、需知、收获、讲师昵称、讲师职位、课程图片、综合评分、内容实用、简洁易懂、逻辑清晰 }


将课程的属性拆分成课程表，在这个表中，因为不可能有重名的课程，所以把 `主标题` 设为业务主键，那么 `副标题、方向、分类、难度` 都是直接与主键相依赖的，那么课程是否是 `最新` 的这个属性，我们可以通过课程的上线时间来计算得出，而业务上可以规定上线多长时间的课程都可以定为最新的课程，这里用 `上线时间` 来代替是否是最新的属性，同样，最热属性，可以根据 `学习人数` 得出，学习人数越高，它的热度就越高，`时长、简介` 也是与 主标题相依赖的，人数就是学习人数，`需知、收获` 也是与 主标题相关，`讲师昵称、讲师职位` 在第三范式中也提过了，需要提出来，建立一个讲师表，由于课程与讲师之间存在的是一对一的关系，所以需要将讲师昵称的主键加入到课程表中，`课程图片` 也是与 主标题相关的。 `综合评分、内容实用、简洁易懂、逻辑清晰 ` 对于课程来说，每个用户的评分是一个平均的分数，也是同课程相关的，也可以直接放在这里。

另外对于 `方向、分类、难度` 这几个属性，虽然是和课程相关的，但是只是存储在课程表中的话，还是会出现数据的更新，插入，删除异常的情况。所以需要几个单独的表来存储

  1. `课程方向表`：它用于记录所以课程的方向，无论该课程的方向下是否存在课程，这个表中都可以有记录，并且课程方向表的业务主键就是我们在课程主表中，所记录的课程方向的名称。

  2. `课程分类表`：它用于记录所以课程的分类信息的，如 是不是微服务、区块链、以太坊、人工智能、机器学习、... 。同样，无论我们现在是否有这样分类的课程，那么在这个表中，都可以对这些分类进行维护。那么和课程方向表类似的，我们仍然需要使用，在课程主表中出现过的属性分类，分类名称作为该表的主键。

  3. `课程难度表`：它用于维护难度分级的，一门课程是 初级、中级、高级 ？我们仍然需要使用，在课程主表中出现过的属性难度，难度名称作为该表的主键。


> 课程表
>
> | 主标题 (PK) | 副标题  | 方向 |分类 | 难度 | 上线时间 |
> | ----- | ------- | ----- |----- |----- |----- |
>
> |学习人数| 时长 | 简介  | 需知 | 收获 | 讲师昵称 | 课程图片 |
> |-----| ----- | ------- | ----- |----- |----- |----- |
>
> | 综合评分 | 内容实用 | 简洁易懂  | 逻辑清晰 |
> | ----- | ----- | ------- | ----- |
>
> <br/>
> <br/>
> <br/>
>
> 讲师表
>
> | 讲师昵称 | 讲师职位 | ...  |
> | ----- | ----- | ------- |
>
> <br/>
> <br/>
> <br/>
>
> 课程方向表
>
> | 课程方向名称 | 增加时间 | ...  |
> | ----- | ----- | ------- |
>
> <br/>
> <br/>
> <br/>
>
> 课程分类表
>
> | 分类名称 | 增加时间 | ...  |
> | ----- | ----- | ------- |
>
> <br/>
> <br/>
> <br/>
>
> 课程难度表
>
> | 课程难度 | 增加时间 | ...  |
> | ----- | ----- | ------- |
>

<br/>
<br/>
<br/>

> 课程列表对象

- 课程列表的属性：{ 章节名、小节名、说明、小节时长、章节URL、视频格式 }

看下，是否可以用一张表，来存储所有的属性，如果要在这个表中选择一个业务主键的话呢！那么就只能使用 `章节名、小节名` 作为一个联合主键，才能保证主键的唯一性。

我们看 `说明` 其实只和 `章节名` 有依赖关系，同时 `小节时长、章节 URL、视频格式` 也只同 `小节名` 有关系，这显然违背的第二范式。非主键要依赖于全部业务主键。

所以，这里要拆分。将各自对应的属性放在一个表中。

具体来说，就是将 `课程章节名、说明` 独立出来，形成一张 `章节表`。同时呢，为了保存 `课程表` 中同这个 `课程章节表` 之间的关联关系，我们还要一张同 `课程章节表` 以及 `课程表` 之间的关联表，关联表只有两个属性。就是 `课程表的主键` 和 `课程章节表的主键`。

同样，把剩下的几个属性，存储在 `课程小节表` 中，使用 `小节名称` 作为主键。并且为了保存 `课程小节表` 和 `课程章节表` 之间的关联关系，同样需要一张它们之间的关联关系表。这个表中包括 `课程主标题(PK)、课程章节名(PK)、小节名称(PK) `

通过以上几步，就确定了课程列表逻辑的存储方式，并且保证了这种设计是符合数据库设计范式的要求的。

>
> 课程章节表
>
> | 课程章节名 | 说明 | 章节编号 |
> | ----- | ----- | ------- |
>
> <br/>
> <br/>
> <br/>
>
> 课程表 与 课程章节表 的联系表
>
> | 课程主标题 | 课程章节名 |
> | ----- | ----- |
>
> <br/>
> <br/>
> <br/>
>
> 课程小节表
>
> | 小节名称 | 小节视频url | 视频格式 | 小节时长 | 小节编号 |
> | ----- | ----- | ----- | ----- | ----- |
>
> <br/>
> <br/>
> <br/>
>
> 课程小节表 和 课程章节表 的关系表
>
> | 课程主标题 | 课程章节名 | 小节名称 |
> | ----- | ----- | ----- |
>


<br/>
<br/>
<br/>

> 讲师对象

- 讲师的属性：{ 讲师昵称、密码、性别、省、市、职位、经验、积分、关注人数、粉丝人数 }

首先，先找到这个表中的主键属性，那 `讲师昵称` 就是了，由于这是一个单属性值的主键，天生就符合第二范式的要求

接下来，看其他属性是否存在依赖关系，可以看到，其他属性都完全和主键是依赖的，所以都可以存放在一张表中。在之前分析课程时，也拆出了一个讲师表，并且里面也包含了 `讲师昵称，讲师职位`

这里还有一个和 `讲师对象` 类似的实体，那就是 `用户对象` 这个属性，这里就先跳过其他的实体，看看 `用户对象`

<br/>
<br/>

> 用户对象

- 用户的属性：{ 用户昵称、密码、性别、省、市、职位、说明、积分、关注人数、粉丝人数 }

可以看出来，这个与上面的讲师对象表就很类似。这里可以使用 `用户昵称` 来标识每一个用户，其他属性也都完全和主键是依赖的，

<br/>
<br/>

- 讲师表：{ 讲师昵称、密码、性别、省、市、职位、经验、积分、关注人数、关注人数 }

- 用户表：{ 用户昵称、密码、性别、省、市、职位、说明、积分、关注人数、粉丝人数 }

这两个表的属性时十分类似的，他们之间唯一的不同就是昵称字段，并且讲师也是一位特殊的用户，如果要 `讲师表` 和 `用户表` 两个表来存储用户信息的话，那么讲师这个用户信息将会存在两个表中，这就造成了数据的冗余，并且很难保证两个表的讲师信息是一致的，那么久需要考虑将这两个表合并一下。

那么只要在用户表中加入一个讲师标识，那么就可以共用一张表。


- 用户表：{ 用户昵称、密码、性别、省、市、职位、说明、积分、关注人数、粉丝人数、讲师标识 }

>
> 用户表
>
> | 用户昵称 | 密码 | 性别 | 省 | 市 | 职位 |说明 |积分 |关注人数 |关注人数 |
> | --- | -- | --- |---|--- |-- |-- |--- |--- |--- |
>

<br/>
<br/>
<br/>

> 问答评论对象

- 问答评论属性：{ 类型、标题、内容、关联章节、浏览量、发布时间、用户昵称 }

那么在这些属性中，用什么属性来标识问答评论的一条记录是合适的呢？

评论标题？显然不能，所以这个就不能用单一的属性去标识，那么久只能用 `标题、用户昵称、关联章节` 来标识一条问答、评论。

那么这里如果记录 `关联章节` 呢？是不是只能用 `课程章节的业务主键` 来记录呢？因此我们不得不把 `课程章节的关联表的业务主键`(课程主标题、课程章名、小节名称) 给加进来

- 问答评论表：{ 标题、课程主标题、课程章名、小节名称、用户昵称、父评论标题、内容、类型、浏览量、发布时间 }

>
> 问答评论表
>
> | 标题 | 课程主标题 | 课程章名 | 小节名称 | 用户昵称 |
> | --- | -- | --- |---|--- |
>
>| 父评论标题 |内容 |类型 |浏览量 |发布时间 |
>|-- |--- |--- |--- |--- |

这里多增加了一个 `父评论标题`。无论是问答还是评论、都是可以被回复的，如果我们这一条评论是对其他评论、问答的一个回复的话，那么这个标题就是被评论、问答回复的标题了。


<br/>
<br/>
<br/>

> 笔记对象

- 笔记的属性：{ 用户昵称、关联章节、笔记标题、笔记内容、发布时间 }


同样，我们也不能只使用 `笔记标题` 来作为一条数据的唯一标识，所以还是需要使用到 `用户昵称、关联章节、笔记标题` 来共同标识一条信息，同样 `关联章节` 也是使用 `课程章节的关联表的业务主键`(课程主标题、课程章名、小节名称) 。

>
> 笔记表
>
> | 笔记标题 | 课程主标题 | 课程章名 | 小节名称 | 用户昵称 | 笔记内容 |发布时间 |
> | --- | -- | --- |---|--- |-- |-- |
>

<br/>
<br/>
<br/>

> 评价对象

- 评价的属性：{ 用户昵称、课程主标题、内容、综合评分、内容实用、简洁易懂、逻辑清晰、发布时间 }

评价是针对课程来进行的，每一个学习了课程的用户，都可以对课程进行一次评价，所以就可以使用 `用户表的业务组件`(用户昵称) 和 `课程表的业务主键`(课程主标题) 作为 `联合主键` 来唯一标识出每一条用户的评价。其余属性都是依赖于这两个属性的。

这里可以看出，只有选择了一门课程的用户，才能进行评价，因此，还需要一张 `用户和所选课程的关联关系表`，也就是 `用户选课表`

>
> 评价表
>
> | 用户昵称 | 课程主标题 | 内容 | 综合评分 | 内容使用 | 简洁易懂 |逻辑清晰 |发布时间 |
> | - | - | - | - | - | - | - | - |
>
> <br/>
> <br/>
> <br/>
>
> 用户选课表
>
> | 用户昵称 | 课程主标题 | 选课时间 | 累积听课时长 |
> | - | - | - | - |
>

<br/>
<br/>
<br/>

以上，就是根据数据库的设计范式，设计出的表。这样的设计，使用起来是否真的方便呢？

如果我们想查询一门课程的相关信息，如 `课程主标题，课程方向，章节名称，章节说明，小节名称，小节时长` ，根据上面设计的表。我们需要从 `课程表`、`章节表`、`小节表` 这三张表中获取，并且为了取出 `章节信息、小节信息`，我们还需要使用 `课程表 与 课程章节表 的关联表` 和 `课程章节表 和 课程小节表 的关联表 `，这样就关联五个表，在 MySQL 中关联的表越多，性能越差，而且课程信息这种查询，在项目中使用还是非常频繁的。必定会拖累整个系统的性能的。

这里虽然是按照设计范式进行设计的。但是出于业务查询性能的考虑，我们还要对范式划设计的表进行优化。




<br/>
<br/>
<br/>

## 反范式划设计

在优化后的表结构后，通常或多或少的都会违反一些范式化的要求，会存在一些数据的冗余，这种优化方式就叫做 **反范式化设计**。

在进行 **反范式化设计** 设计的情况下，多数情况下，都是 `以空间换时间`，也就是为了提高查询性能，而适度的增加了数据的冗余。

再次分析下，这几个表之间的关系。

<br/>
<br/>

`课程表` 和 `章节表` 之间存在一对多的关系，也就是说一门 `课程` 中可以有多个 `章节`，但是一个 `章节` 只会属于一门 `课程`。这样我们可以不需要这张关联关系表。直接将两个表合在一起。

- 课程章节表：{ 课程章节名(PK)、说明、章节编号 }
- 课程同章节的联系表：{ 课程主标题(PK)、课程章节(PK) }

合并后

>
> 课程章节表
>
> | 课程主标题(PK) | 课程章节名(PK) | 章节说明 | 章节编号 |
> | - | - | - | - |
>

这样看起来虽然违反了设计范式，但在实际业务查询中，却让我们少关联一张表，从而提升了查询性能，在一个需要被频繁查询的表，进行这样的反范式化设计，还是很划算的。

<br/>
<br/>
<br/>

同理，课程小节表

`课程章节表` 和 `课程小节表` 之间也是存在一对多的关系，也就是说一个 `章节` 中可以有多个 `小节`，但是一个 `小节` 只会属于一个 `章节`。



- 课程小节表：{ 小节名称(PK)、小节视频url、视频格式、小节时长、小节编号 }
- 课程章节同小节关系表：{ 课程主标题(PK)、课程章节(PK)、小节名称(PK) }

合并后

>
> 课程小节表
>
> | 课程主标题(PK) | 课程章节名(PK) | 小节名称(PK) | 小节视频url |视频格式 |小节时长 |小节编号 |
> | - | - | - | - | - | - | - |
>


<br/>
<br/>
<br/>

### 总结

当前课程表从五个变成了三个

>
> 课程表
>
> | 主标题 (PK) | 副标题  | 方向 |分类 | 难度 | 上线时间 |
> | ----- | ------- | ----- |----- |----- |----- |
>
> |学习人数| 时长 | 简介  | 需知 | 收获 | 讲师昵称 | 课程图片 |
> |-----| ----- | ------- | ----- |----- |----- |----- |
>
> | 综合评分 | 内容实用 | 简洁易懂  | 逻辑清晰 |
> | ----- | ----- | ------- | ----- |
>
> <br/>
> <br/>
>
> 课程章节表
>
> | 课程主标题(PK) | 课程章节名(PK) | 章节说明 | 章节编号 |
> | - | - | - | - |
>
> <br/>
> <br/>
>
> 课程小节表
>
> | 课程主标题(PK) | 课程章节名(PK) | 小节名称(PK) | 小节视频url |视频格式 |小节时长 |小节编号 |
> | - | - | - | - | - | - | - |
>

反范式化设计后，查询的信息从五个表的关联到三个表的关联查询，可以发现，对表的范式化设计约严格，表就分的约细，查询时，需要关联的表就越多，这时候就需要进行反范式化设计了，反范式化是为了减少查询关联表时的数量，从而提升数据的查询性能，当我们在反范式化或者范式化的时候，都需要掌握一个度，不能过度的去设计。那这个度的标准就取决于我们关联表的数量。


<br/>
<br/>
<br/>


## 物理设计

MySQL 常见的存储引擎

| 引擎名称 | 事务 | 说明 |
| - | - | - |
| MYISAM | N | MySQL5.6之前的默认引擎，最常用的非事务型存储引擎 |
| CSV | N | 以 CSV 格式存储的非事务型存储引擎 |
| Archive | N | 只允许查询和新增数据而不运行修改的非事务型存储引擎 |
| Memory | N | 是一种易失性非事务型存储引擎 |
| INNODB | Y | 最常用的事务型存储引擎 |



<br/>
<br/>
<br/>

**InnoDB 存储引擎的特点**

- 事务性存储引擎支持 ACID
- 数据按主键聚集存储
- 支持行级锁及 MVCC
- 支持 Btree 和自适应 Hash 索引
- 支持全文和空间索引



InnoDB 存储引擎和之前所说的存储引擎相比，最重要的特点就是InnoDB 存储引擎它是一款事务性的存储引擎，其完全支持事务的原子性(Atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability) 的特点。换句话说呢，如果在我们的业务场景中，需要使用到数据库事务的话，最好的选择就是 InnoDB 存储引擎，并且要注意，在需要事务支持的场景中，一定不要混合使用事务型存储引擎和非事务型存储引擎，如果我们在一个事务中同时使用了事务型存储引擎的表和非事务型存储引擎的表的话，那么一旦事务由于某种原因进行了回滚，那么对于非事务型存储引擎中的数据所进行的修改就是无法回滚的，这样就破坏了事务一致性的要求，同时呢，也就破坏了数据的完整性。

InnoDB 存储引擎的第二个特点就是 InnoDB 表中的数据，在逻辑上，它是按照表中主键的顺序来存储的，也就是说 InnoDB 表中的主键，它是一种聚集索引的主键，我们在选择使用什么样的列，作为表中主键的时候，就要特别注意了，和 MYISAM 存储引擎使用的是堆的存储方式不同，在具有聚集索引主键的存储引擎中，每一个非主键的索引的叶子节点所指向的都是数据行中的主键，而不是数据行的物理存储位置，因此呢，主键的大小就直接影响到索引查找数据的性能，另一方面，由于数据是按主键的逻辑顺序来进行存储的，如果键的顺序经常无故的变化，一定会照成数据的迁移，这样呢也会带来 IO 性能上的一些损耗，所以呢，一般情况下，如果我们使用 InnoDB 存储引擎的表，都是建议使用一个自增 id，来作为一个表的主键的，那么从这几点上来看呢，我们之前对表进行逻辑设计时，所选择的业务主键，并不适合作为 InnoDB 表的主键使用，但是我们现在又需要使用 InnoDB 存储引擎来存储我们的业务数据，这个时候我们就要给每一个表，在加一个自增 id 列，来作为表的数据库主键，而之前选择的业务主键，我们可以在上面建立一个唯一索引，这样呢，也同样可以保证其数据是唯一的。

InnoDB 存储引擎的第三个特点，就是它支持的是行级锁的存储引擎，也就是说，在进行数据读写操作时，只会在需要读写数据行上加锁，而不和 MYISAM 一样，在整个表上来加锁，这无疑就能大大增加 InnoDB 在并发上的处理能力，另外它还支持 MVCC 多版本的并发控制，可以进一步的避免读写操作的互相堵塞，所以它非常适合在高并发的读写混合的应用场景中使用。

那么从对索引方面的知识来看，InnoDB 除了支持 Btree 索引，还支持自适应 Hash 索引（由 InnoDB 引擎根据数据统一信息，在内存中自动建立的 Hash 索引，这种索引只能用于等值查询，并且只能由 InnoDB 内部维护，不需要人为的干预）。

并且在 MySQL5.6 之后，InnoDB 同时也支持了全文索引，在5.7之后的版本中，InnoDB 又支持了对空间类型数据的索引。


<br/>
<br/>
<br/>

根据 InnoDB 聚集索引主键的特点，我们需要为每一个表单独增加一个自增 id，来作为表的数据库主键使用，那么由于这个数据库主键的大小通常要比业务主键小的多，所以表与表之间的关联，我们也可以通过数据库主键来进行，这样就会比使用业务主键来关联查询更有效率，那么现在来看下表结构


课程表： { 课程ID(主键)、主标题、副标题、方向ID、分类ID、难度ID、上线时间、学习人数、简介、需知、收获、讲师ID、课程图片、综合评分、内容使用、简洁易懂、逻辑清晰 }

课程ID：自增ID(1, 2, 3, 4, 5)，这样课程表的逻辑存储顺序就会按照自增ID的顺序来进行存储的，我们可以保证后加入表中的数据，一定是排在bi表的末尾的，不会因新增的数据而改变之前数据的逻辑存储的顺序。如果我们要使用课程主标题来作为表的主键，无疑是无法保证做到这一点的，同时为了课程主标题的唯一性，我们可以在课程的主标题列上建立一个唯一的索引，另外，我们还更新了一些关联其他表所用到的列，如 ( 课程方向名称 -> 方向表的主键：课程方向的ID，课程分类名称 -> 分类ID，课程难度名称 -> 难度ID，讲师昵称 -> 用户表的用户ID )。


这种数据库主键替换业务主键的方式，有利有弊，好处是我们保证数据的一致性，如讲师昵称，我们只要修改用户表的用户昵称，当我们在查询课程信息的时候，由于是关联查询，所以就可以同时修改课程信息表中的昵称。缺点就是我们要用课程表同用户表关联之后，才能获取讲师的昵称，所以具体是要增加数据冗余的方式减少关联，还是要保证数据的一致性，就要看业务的具体情况，这里选择增加表的关联，来保证数据的一致性，这样可以减少数据的冗余的一种方式。


> 修改

课程章节表：{ 章节ID(主键，自增ID)、课程ID、章节名称、章节说明、章节编号 }
课程小节表：{ 小节ID(AI PK)、课程ID、章节ID、小节名称、小节视频URL、视频格式、小节时长、小节编号 }
课程方向表：{ 课程方向ID(AI PK)、课程方向名称、增加时间 }
课程分类表：{ 课程分类ID(AI PK)、课程分类名称、增加时间 }
课程难度表：{ 课程难度ID(AI PK)、课程难度名称、增加时间 }
用户表：{ 用户ID(AI PK)、用户昵称(为了保证唯一性，还需要在该属性上增加一个非空唯一索引 NN UQ)、密码、性别、省、市、职位、说明、经验、积分、关注人数、粉丝人数、讲师标识 }
问答评论表：{ 评论ID(AI PK)、父评论ID、课程ID、章节ID、小节ID、评论标题、用户ID、内容、类型、浏览量、发布时间 }
笔记表：{ 笔记ID(AI PK)、课程ID、章节ID、小节ID、笔记标题、用户昵称、笔记内容、发布时间 }
评价表：{ 评价ID(AI PK)、用户ID、课程ID、内容、综合评分、内容实用、简洁易懂、逻辑清晰、发布时间 }
用户选课表：{ 用户选课ID(AI PK)、用户ID、课程ID、选课时间、累积听课时长 }

<br/>

到这里，就需要进行物理设计的第二步，如何为表中的列选择合适的数据类型。

<br/>
<br/>
<br/>

## 数据类型

> 常用的整数类型

| 列类型 | 存储空间 | 范围(有符号 SIGEND) | 范围(无符号 UNSIGEND) | 用途 |
| - | - | - | - | - | - | - | - |
| tinyint | 1字节 |  -128 ~ 127  | 0 ~ 255 | 小整数值 |
| smallint | 2字节 | -32768 ~ 32767 | 0 ~ 65535 | 大整数值 |
| mediumint | 3字节 | -8388608 ~ 8388607 | 0 ~ 16777215 | 大整数值 |
| int | 4字节 | -2147483648 ~ 2147483647 | 0 ~ 4294967295 | 大整数值 |
| bigint | 8字节 | -9223372036854775808 ~ 9223372036854775807 | 0 ~ 18446744073709551615 | 极大整数值 |

<br/>
<br/>
<br/>

> 常用的浮点类型

| 列类型 | 存储空间 | 用途 | 是否精确类型 |
| - | - | - | - | - | - | - | - |
| FLOAT | 4字节 | 单精度 浮点数值 | 否 |
| DOUBLE | 8字节 | 双精度 浮点数值 | 否 |
| DECIMAL | 每4个字节存9个数字，小数点占一个字节 | 小数值 | 是 |



<br/>
<br/>
<br/>

> 常用的时间类型


| 列类型 | 存储空间 | 格式 | 范围 | 用途 |
| - | - | - | - | - | - | - | - | - |
| DATE | 3字节 | YYYY-MM-DD | 1000-01-01  <br/>~ <br/> 9999-12-31 | 日期值 |
| TIME | 3~6字节 | HH:MM:SS[.微妙值] | '-838:59:59'  <br/>~ <br/> '838:59:59' | 时间值或持续时间 |
| YEAR | 1字节 | YYYY | 1901 ~ 2155 | 年份值 |
| DATETIME | 5~8字节 | YYYY-MM-DD HH:MM:SS[.微妙值] | 1000-01-01 00:00:00  <br/>~<br/> 9999-12-31 23:59:59 | 混合日期和时间值 |
| TIMESTAMP | 4~7字节 | YYYYMMDD HHMMSS[.微妙值] | 1970-01-01 00:00:01  (UTC)  <br/>~<br/> 2038-1-19 03:14:07 (UTC) | 混合日期和时间值，时间戳 |

> 微秒

| 微秒 | 存储空间 | |  |  |  |
| - | - | - | - | - | - |
| 0 | 0 bytes | | dt0 | time | 16:16:16 |
| 1，2 | 1 bytes | | dt2 | time(2) | 16:16:16.16 |
| 3，4 | 2 bytes | | dt4 | time(4) | 16:16:16.1616 |
| 5，6 | 3 bytes | | dt5 | time(6) | 16:16:16.161616 |


<br/>
<br/>
<br/>

> 常用的字符串类型


| 列类型 | 范围 | 说明 |
| - | - | - |
| Char(M) | M = 1 ~ 255 字符 | 固定长度 |
| VarChar(M) | 一行中所有 varvhar 类型的列所占用的字节数不能超过 65535 个字节。 <br/>( UTF8mb4 VarChar(10) = 40 字节 ） | 存储可变长度的M个字符|
| TinyText | 0 ~ 255 bytes | 可变长度 |
| Text | 0 ~ 65535 bytes | 可变长度 |
| MediumTest | 0 ~ 16777215 bytes | 可变长度 |
| LongTest | 0 ~ 4294967295 bytes | 可变长度 |
| Enum | 集合最大数目为 65535 个枚举值 | 只能插入列表中的值 |

<br/>
<br/>
<br/>

> 如何为数据库选择合适的数据类型

- 优先选择符合存储数据需求的最小数据类型。

- 谨慎使用 ENUM、TEXT 字符串类型。

- 同财务相关的数值型数据，必须使用 decimal 类型。

<br/>
<br/>
<br/>


> 课程表

| 列名 | 数据类型 | 列名 | 数据类型 |
| - | - | - | - |
| 课程ID(PK) | int unsigned | 课程简介 | varchar(200) |
| 主标题(UK) | varchar(20) | 学习需知 | varchar(200) |
| 副标题 | varchar(50) | 课程收获 | varchar(200) |
| 课程方向ID | smallint unsigned | 讲师ID | int unsigned |
| 课程分类ID | smallint unsigned | 课程主图片 | varchar(200) |
| 课程难度ID | smallint unsigned | 内容评分 | decimal(3, 1) |
| 上线时间 | datetime | 简单易懂 | decimal(3, 1) |
| 学习人数 | int unsigned | 逻辑清晰 | decimal(3, 1) |
| 课程时长 | time | 综合评分 | decimal(3, 1) |

<br/>

> 课程章节表

| 列名 | 数据类型 |
| - | - |
| 章节ID(PK) | int unsigned |
| 课程ID(UK) | int unsigned |
| 章节名称(UK) | varchar(50) |
| 章节说明 | varchar(200) |
| 章节编号 | tinyint(2) unsigned ZEROFILL |


章节编号: 是章节在课程中的顺序，使用了无符号的 tinyint 类型，一门课是不会超过 255 个章节的，和其他整数类型不同的是，给 tinyint 增加了一个宽度限制，并且增加了 ZEROFILL 属性，这里的宽度 2，并不能限制 tinyint 存储的数值的范围，也不能限制它所使用的存储空间的大小，这个 2 的具体作用就是保住章节编号列，至少是一个两位的整数，而 ZEROFILL 是在章节编号不足两位的时候，在前面补 0。

<br/>

> 课程小节表

| 列名 | 数据类型 |
| - | - |
| 小节ID(PK) | int unsigned |
| 章节ID(UK) | int unsigned |
| 课程ID(UK) | int unsigned |
| 小节名称(UK) | varchar(50) |
| 小节URL | varchar(200) |
| 视频格式 | enum('avi', 'mp4', 'mpeg') |
| 小节时长 | time |
| 章节编号 | tinyint(2) unsigned ZEROFILL |

<br/>

> 课程分类表

| 列名 | 数据类型 |
| - | - |
| 课程分类ID(PK) | smallint unsigned |
| 分类名称(UK) | varchar(10) |
| 增加时间 | timestamp |

<br/>

> 课程方向表

| 列名 | 数据类型 |
| - | - |
| 课程方向ID(PK) | smallint unsigned |
| 方向名称(UK) | varchar(10) |
| 增加时间 | timestamp |

<br/>

> 课程难度表

| 列名 | 数据类型 |
| - | - |
| 课程难度ID(PK) | smallint unsigned |
| 难度名称(UK) | varchar(10) |
| 增加时间 | timestamp |


<br/>

> 用户表

| 列名 | 数据类型 | 列名 | 数据类型 |
| - | - | - | - |
| 用户ID(PK) | int unsigned | 经验值 | mediumint unsigned |
| 用户昵称(UK) | varchar(20) | 积分 | int unsigned |
| 密码 | char(32) | 关注人数 | int unsigned |
| 性别 | char(2) | 粉丝人数 | int unsigned |
| 省 | varchar(20) | 讲师标识 | tinyint unsigned |
| 市 | varchar(20) | 注册时间 | datetime |
| 职位 | varchar(10) | 用户状态 | tinyint unsigned |
| 说明 | varchar(100) |  |  |

<br/>

> 问答评论表

| 列名 | 数据类型 |
| - | - |
| 评论(PK) | int unsigned |
| 用户ID | int unsigned |
| 课程ID | int unsigned |
| 章节ID | int unsigned |
| 小节ID | int unsigned |
| 父评论ID | int unsigned |
| 评论标题 | varchar(50) |
| 评论内容 | text |
| 评论类型 | enum('问答', '评论') |
| 浏览量 | int unsigned |
| 发布时间 | datetime |

<br/>

> 笔记表

| 列名 | 数据类型 |
| - | - |
| 笔记(PK) | int unsigned |
| 用户ID | int unsigned |
| 课程ID | int unsigned |
| 章节ID | int unsigned |
| 小节ID | int unsigned |
| 笔记标题 | varchar(50) |
| 评论内容 | text |
| 发布时间 | datetime |


<br/>

> 评论表

| 列名 | 数据类型 |
| - | - |
| 评论(PK) | int unsigned |
| 用户ID | int unsigned |
| 课程ID | int unsigned |
| 内容评分 | decimal(3, 1) |
| 简单易懂 | decimal(3, 1) |
| 逻辑清晰 | decimal(3, 1) |
| 综合评分 | decimal(3, 1) |
| 发布时间 | datetime |

<br/>

> 用户选课表

| 列名 | 数据类型 |
| - | - |
| 选课(PK) | int unsigned |
| 用户ID | int unsigned |
| 课程ID | int unsigned |
| 选课时间 | datetime |
| 累积听课时间 | time |


<br/>
<br/>
<br/>

## 表、列命名

- 所有数据库对象名称必须使用小写字母可选用下划线分割。

- 所有数据库对象名称定义禁止使用 MySQL 保留关键字。

- 数据库对象的命名要做到见名知意，并且最好不要超过 32 个字。

- 临时表必须以 tmp 为前缀并以日期为后缀。

- 用于备份的库，表必须以 bak 为前缀并以日期为后缀。

- 所有存储相同数据的列名和列类型必须一致。


<br/>
<br/>
<br/>


> 课程表 imc_course

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 课程ID(PK) | course_id | int unsigned |
| 主标题(UK) | title | varchar(20) |
| 副标题 | title_desc | varchar(50) |
| 课程方向ID | type_id | smallint unsigned |
| 课程分类ID | class_id | smallint unsigned |
| 课程难度ID | level_id | smallint unsigned |
| 上线时间 | online_time | datetime |
| 学习人数 | study_cnt | int unsigned |
| 课程时长 | course_time | time |
| 课程简介 | intro | varchar(200) |
| 学习需知 | info | varchar(200) |
| 课程收获 | harvset | varchar(200) |
| 讲师ID | user_id | int unsigned |
| 课程主图片 | main_pic | varchar(200) |
| 内容评分 | content_score | decimal(3, 1) |
| 简单易懂 | level_score | decimal(3, 1) |
| 逻辑清晰 | logic_score | decimal(3, 1) |
| 综合评分 | score | decimal(3, 1) |

<br/>

> 课程章节表 imc_chapter

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 章节ID(PK) | chapter_id | int unsigned |
| 课程ID(UK) | course_id | int unsigned |
| 章节名称(UK) | chapter_name | varchar(50) |
| 章节说明 | chapter_info | varchar(200) |
| 章节编号 | chapter_no | tinyint(2) unsigned ZEROFILL |

<br/>

> 课程小节表 imc_subsection

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 小节ID(PK) | sub_id | int unsigned |
| 章节ID(UK) | chapter_id | int unsigned |
| 课程ID(UK) | course_id | int unsigned |
| 小节名称(UK) | sub_name | varchar(50) |
| 小节URL | sub_url | varchar(200) |
| 视频格式 | video_type | enum('avi', 'mp4', 'mpeg') |
| 小节时长 | sub_time | time |
| 小节编号 | sub_no | tinyint(2) unsigned ZEROFILL |





<br/>

> 课程分类表 imc_class

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 课程分类ID(PK) | class_id | smallint unsigned |
| 分类名称(UK) | class_name | varchar(10) |
| 增加时间 | add_time | timestamp |

<br/>

> 课程难度表 imc_level

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 课程难度ID(PK) | level_id | smallint unsigned |
| 难度名称(UK) | level_name | varchar(10) |
| 增加时间 | add_time | timestamp |


<br/>

> 课程方向表 imc_type

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 课程方向ID(PK) | type_id | smallint unsigned |
| 方向名称(UK) | type_name | varchar(10) |
| 增加时间 | add_time | timestamp |






<br/>

> 用户表 imc_user

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 用户ID(PK) | user_id | int unsigned |
| 用户昵称(UK) | user_nick | varchar(20) |
| 密码 | user_pwd | char(32) |
| 性别 | sex | char(2) |
| 省 | province | varchar(20) |
| 市 | city | varchar(20) |
| 职位 | position | varchar(10) |
| 说明 | mem | varchar(100) |
| 经验值 | exp_cnt | mediumint unsigned |
| 积分 | score | int unsigned |
| 关注人数 | follow_cnt | int unsigned |
| 粉丝人数 | fans_cnt | int unsigned |
| 讲师标识 | is_teacher | tinyint unsigned |
| 注册时间 | reg_time | datetime |
| 用户状态 | user_status | tinyint unsigned |



<br/>

> 问答评论表 imc_question

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 评论(PK) | quest_id | int unsigned |
| 用户ID | user_id | int unsigned |
| 课程ID | course_id | int unsigned |
| 章节ID | chapter_id | int unsigned |
| 小节ID | sub_id | int unsigned |
| 父评论ID | replyid | int unsigned |
| 评论标题 | quest_title | varchar(50) |
| 评论内容 | quest_content | text |
| 评论类型 | quest_type | enum('问答', '评论') |
| 浏览量 | view_cnt | int unsigned |
| 发布时间 | add_time | datetime |


<br/>

> 笔记表 imc_note

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 笔记(PK) | note_id | int unsigned |
| 用户ID | user_id | int unsigned |
| 课程ID | course_id | int unsigned |
| 章节ID | chapter_id | int unsigned |
| 小节ID | sub_id | int unsigned |
| 笔记标题 | note_title | varchar(50) |
| 笔记内容 | note_content | text |
| 发布时间 | add_time | datetime |

<br/>

> 评论表 imc_classvalue

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 评价(PK) | value_id | int unsigned |
| 用户ID | user_id | int unsigned |
| 课程ID | course_id | int unsigned |
| 内容评分 | content_score | decimal(3, 1) |
| 简单易懂 | level_score | decimal(3, 1) |
| 逻辑清晰 | logic_score | decimal(3, 1) |
| 综合评分 | score | decimal(3, 1) |
| 发布时间 | add_time | datetime |


<br/>

> 用户选课表 imc_selectcourse

| 列名 | 代码 | 数据类型 |
| - | - | - |
| 选课(PK) | select_id | int unsigned |
| 用户ID | user_id | int unsigned |
| 课程ID | course_id | int unsigned |
| 选课时间 | select_time | datetime |
| 累积听课时间 | study_time | time |

















































