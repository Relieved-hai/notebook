(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{1250:function(e,t,a){"use strict";a.r(t);var r=a(19),s=Object(r.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"什么是-event-loop？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-event-loop？","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是 event loop？")]),e._v(" "),r("p",[e._v("从广义上来说，"),r("code",[e._v("event loop")]),e._v(" 就是一种【user agents 用于协调各种事件，用户交互，脚本执行，网络活动等执行时机的】调度机制。")]),e._v(" "),r("p",[e._v("实现 "),r("code",[e._v("event loop")]),e._v(" 的 user agent 有好多个。比如说：")]),e._v(" "),r("ul",[r("li",[e._v("window")]),e._v(" "),r("li",[e._v("worker\n"),r("ul",[r("li",[e._v("dedicated worker")]),e._v(" "),r("li",[e._v("shared worker")]),e._v(" "),r("li",[e._v("service worker")])])]),e._v(" "),r("li",[e._v("worklet")]),e._v(" "),r("li",[e._v("nodejs")])]),e._v(" "),r("br"),e._v(" "),r("p",[e._v("实现 "),r("code",[e._v("event loop")]),e._v(" 的 "),r("strong",[e._v("通用算法")]),e._v("（注意，这是简单的，通用的算法）大概是这样的：")]),e._v(" "),r("ol",[r("li",[e._v("时刻监视 "),r("code",[e._v("task queue")]),e._v(", 当 "),r("code",[e._v("task queue")]),e._v(" 不为空的时候:\n"),r("ul",[r("li",[e._v("执行队列中入队时间最久的那个 "),r("code",[e._v("task")])])])]),e._v(" "),r("li",[e._v("休眠。直到等到有可执行的 "),r("code",[e._v("task")]),e._v(" 出现，跳回 "),r("code",[e._v("1")]),e._v("。")])]),e._v(" "),r("p",[e._v("用代码来简单表示就是：")]),e._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("while")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("queue"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("waitForTask")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  queue"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("processNextTask")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br")])]),r("p",[e._v("作为单线程的 javascript 就是通过 "),r("code",[e._v("event loop")]),e._v(" 来实现了它的异步编程特性。")]),e._v(" "),r("br"),e._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[e._v("鉴于实现 "),r("code",[e._v("event loop")]),e._v("的 user agent 之多和时间有限，在这里只是深入讨论浏览器中的 "),r("code",[e._v("event loop")]),e._v("（特指 "),r("code",[e._v("window event loop")]),e._v("）和 "),r("code",[e._v("nodejs")]),e._v(" 中的 "),r("code",[e._v("event loop")]),e._v("。")])]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#术语","aria-hidden":"true"}},[e._v("#")]),e._v(" 术语")]),e._v(" "),r("p",[e._v("需要反复强调的是，概念是人类有效沟通交流的基础，更确切地说，将同一个（概念）“名”理解为同一个“实”，即概念理解的一致性是人类有效沟通交流的基础。概念落实到某个相关领域就称之为“术语”。鉴于无论是官方文档还是业内技术文章在使用术语的不一致性，我们有必要梳理一下阐述event loop过程中所涉及的术语，如下：")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"task"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#task","aria-hidden":"true"}},[e._v("#")]),e._v(" task")]),e._v(" "),r("p",[e._v("在MDN的诸多阐述event loop相关的文档中，都使用了这个术语。在"),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文档中"),r("OutboundLink")],1),e._v("，task的定义是这么下的：")]),e._v(" "),r("blockquote",[r("p",[e._v("A task is any JavaScript code which is scheduled to be run by the standard mechanisms such as initially starting to run a program, an event callback being run, or an interval or timeout being fired.")])]),e._v(" "),r("p",[e._v("这篇文档中说到：")]),e._v(" "),r("blockquote",[r("p",[e._v("The tasks form a queue, so-called “macrotask queue” (v8 term)")])]),e._v(" "),r("p",[e._v("可以看到，我们天天一口一个的 "),r("code",[e._v("macrotask")]),e._v("，比如："),r("code",[e._v("setTimeout")]),e._v("、"),r("code",[e._v("setInterval")]),e._v(" 等等的 "),r("code",[e._v("callback")]),e._v(" 就是一个 "),r("code",[e._v("“task”")]),e._v("。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"task-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#task-queue","aria-hidden":"true"}},[e._v("#")]),e._v(" task queue")]),e._v(" "),r("p",[e._v("task 会被推入到一个队列当中，等待调度。这个队列就是 "),r("strong",[e._v("task queue")]),e._v("。在 Philip Roberts 的演讲中，他提到了一个叫 "),r("strong",[e._v("“callback queue”")]),e._v(" 的术语，同时他也提到了，它就是 "),r("strong",[e._v("“task queue”")]),e._v(" 的别名。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"macrotask"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#macrotask","aria-hidden":"true"}},[e._v("#")]),e._v(" macrotask")]),e._v(" "),r("p",[e._v("macrotask === task。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"macrotask-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#macrotask-queue","aria-hidden":"true"}},[e._v("#")]),e._v(" macrotask queue")]),e._v(" "),r("p",[e._v("macrotask queue === task queue === callback queue。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"messsage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#messsage","aria-hidden":"true"}},[e._v("#")]),e._v(" messsage")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇MDN文档"),r("OutboundLink")],1),e._v("，通篇下来都在用 "),r("strong",[e._v("“message”")]),e._v(" 这个术语，可以看得出，这个 "),r("code",[e._v("message")]),e._v(" 跟它对应的 "),r("code",[e._v("callback")]),e._v(" 一起，两者可以统一称之为 "),r("strong",[e._v("“task”")]),e._v("。那么里面所说的 "),r("strong",[e._v("“message queue”")]),e._v(" 就是 "),r("strong",[e._v("“task queue”")]),e._v("。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"microtask"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#microtask","aria-hidden":"true"}},[e._v("#")]),e._v(" microtask")]),e._v(" "),r("p",[e._v("MDN：")]),e._v(" "),r("blockquote",[r("p",[e._v("A microtask is a short function which is executed after the function or program which created it exits and only if the JavaScript execution stack is empty, but before returning control to the event loop being used by the user agent to drive the script's execution environment.")])]),e._v(" "),r("p",[e._v("简单理解就是，"),r("code",[e._v("microtask")]),e._v(" 是一个“小”函数（正好呼应了它的名字："),r("code",[e._v("micro")]),e._v("）。这个函数仅在 JavaScript 执行栈为空，并且创建它的函数或程序退出后才会执行。但是，它会在将控制权返回给用户代理之前执行。“控制权返回给用户代理之前”是什么意思呢，其实就是“下一个 "),r("code",[e._v("event loop")]),e._v(" 之前”的意思。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"microtask-queue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#microtask-queue","aria-hidden":"true"}},[e._v("#")]),e._v(" microtask queue")]),e._v(" "),r("p",[e._v("跟 "),r("code",[e._v("macrotask queue")]),e._v(" 一样，"),r("code",[e._v("microtask queue")]),e._v(" 也是用于存放 "),r("code",[e._v("microtask")]),e._v(" 的队列。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"job"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#job","aria-hidden":"true"}},[e._v("#")]),e._v(" job")]),e._v(" "),r("p",[e._v("在 jake archibald 的"),r("a",{attrs:{href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇技术文章"),r("OutboundLink")],1),e._v("中，他指出了 "),r("code",[e._v("“job”")]),e._v(" 的概念来自于 ECMAScript 规范，它与 "),r("code",[e._v("“microtask”")]),e._v(" 几乎等同，但是不完全等同。业界对两者区别的阐述一直处于含糊不清的状态。鉴于整篇文章下来，在他的阐述中，他已经把 "),r("code",[e._v("“job”")]),e._v(" 等同于 "),r("code",[e._v("“microtask”")]),e._v(" 了。所以，我也倾向于采用这种理解。")]),e._v(" "),r("p",[e._v("而另外一位同行 Daniel Chang 在他的技术文章 "),r("a",{attrs:{href:"https://abc.danch.me/microtasks-macrotasks-more-on-the-event-loop-881557d7af6f",target:"_blank",rel:"noopener noreferrer"}},[e._v("Microtasks & Macrotasks — More On The Event Loop"),r("OutboundLink")],1),e._v(" 也秉持着同样的看法：")]),e._v(" "),r("blockquote",[r("p",[e._v("In this write up I’ve been using the term task interchangeably between macrotask and microtask, much of the documentation out there refers to macrotasks as tasks and microtasks as job. Knowing this will make understanding documentation easier.")])]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"call-stack-execution-context-stack"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#call-stack-execution-context-stack","aria-hidden":"true"}},[e._v("#")]),e._v(" call stack/execution context stack")]),e._v(" "),r("p",[e._v("首先，我们先去维基百科上面看看有关于 "),r("code",[e._v("call stack")]),e._v(" 的定义。")]),e._v(" "),r("blockquote",[r("p",[e._v("在计算机科学中，call stack 是一种存储计算机程序当前正在执行的子程序（subroutine）信息的栈结构......使用 call stack 的主要原因是保存一个用于追踪【当前子程序执行完毕后，程序控制权应该归还给谁】的指针.....一个 call stack 是由多个 stack frame 组成。每个 stack frame 对应于一个子程序调用。作为 stack frame，这个子程序此时应该还没有被 return 语句所终结。举个例子，我们有一个叫 DrawLine 的子程序正在运行。这个子程序又被另外一个叫做 DrawSquare 的子程序所调用，那么 call stack 中顶部的布局应该长成下面那样：")])]),e._v(" "),r("p",[r("img",{attrs:{src:a(407),alt:"call_stack"}})]),e._v(" "),r("p",[e._v("结合维基百科给出的定义和 Philip Roberts 的演讲，我们再来看看 MDN 的诸多文档通篇下来使用的 “execution context stack” 这个概念。顾名思义，“execution context stack” 当然是由 “execution context” 组成的，那 “execution context” 又是什么？不难理解，“execution context” 就是维基百科给出示意图中 stack frame 里面的 “Locals of xxx”，即函数执行所需要用到的上下文环境。")]),e._v(" "),r("p",[e._v("最后，我们可以看出，“execution context stack” 其实就是 “call stack” 的子集。因为在 event loop 语境下，我们不关心 stack frame 里面的其他“成分”：“parametres for xxx” 和 “return address”。所以，两者可以等同起来理解。")]),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("br"),e._v(" "),r("h2",{attrs:{id:"小结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#小结","aria-hidden":"true"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),r("p",[e._v("有鉴于业内技术文章对这些术语的使用频率，在本文的阐述中，")]),e._v(" "),r("ul",[r("li",[e._v("相比于 “task”，我会采用 "),r("code",[e._v("“macrotask”")]),e._v(" 的叫法；")]),e._v(" "),r("li",[e._v("相比于“job”，我会采用 "),r("code",[e._v("“microtask”")]),e._v(" 的叫法；")]),e._v(" "),r("li",[e._v("相比于 “execution context stack”，我会采用 "),r("code",[e._v("“call stack”")]),e._v(" 的叫法。")])]),e._v(" "),r("p",[e._v("That is  a deal!")])])},[],!1,null,null,null);t.default=s.exports},407:function(e,t,a){e.exports=a.p+"assets/img/call_stack.b552401f.png"}}]);