(window.webpackJsonp=window.webpackJsonp||[]).push([[376],{1200:function(s,t,a){"use strict";a.r(t);var n=a(19),e=Object(n.a)({},function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"灾难性回溯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#灾难性回溯","aria-hidden":"true"}},[s._v("#")]),s._v(" 灾难性回溯")]),s._v(" "),a("p",[s._v("有些正则表达式看上去很简单，但是执行起来耗时非常非常非常长，甚至会导致 JavaScript 引擎「挂起」。")]),s._v(" "),a("p",[s._v("开发者们很容易一不小心就写出这类正则表达式，所以我们迟早会面对这种意外问题。")]),s._v(" "),a("p",[s._v("典型的症状就是 —— 一个正则表达式有时能正常工作，但对于某些特定的字符串就会消耗 100% 的 CPU 算力，出现“挂起”现象。")]),s._v(" "),a("p",[s._v("在这种情况下，Web 浏览器会建议杀死脚本并重新载入页面。这显然不是我们愿意看到的。")]),s._v(" "),a("p",[s._v("在服务器端 JavaScript 中，在使用这种正则表达式处理用户数据时可能会引发程序漏洞。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h2",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子","aria-hidden":"true"}},[s._v("#")]),s._v(" 例子")]),s._v(" "),a("p",[s._v("假设，我们现在有一个字符串，我们想检查其中是否包含一些单词 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v("，允许字符后跟着可选的空格符 "),a("code",{staticClass:"pattern"},[s._v("\\s?")]),s._v("。")]),s._v(" "),a("p",[s._v("我们使用一个这样的正则 "),a("code",{staticClass:"pattern"},[s._v("^(\\w+\\s?)*$")]),s._v("，它指定了 0 个或更多个此类的字符。")]),s._v(" "),a("p",[s._v("我们运行一下：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^(\\w+\\s?)*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"A good string"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// true")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Bad characters: $@#"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// false")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("这似乎能正常工作。结果是正确的。但是在特定的字符串上，它会消耗很多时间。它耗时太久以至于让 CPU 会跑满 100% 负载，导致 JavaScript 引擎「挂起」。")]),s._v(" "),a("br"),s._v(" "),a("div",{staticClass:"warning custom-block"},[a("p",[s._v("如果你运行下面这个例子，由于 JavaScript 会进入「挂起」状态，因此你可能什么结果都看不到。此时浏览器会停止对事件的响应，UI 也会停止运作。一段时间之后浏览器会建议重新载入页面。所以请谨慎对待：")])]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^(\\w+\\s?)*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"An input string that takes a long time or even makes this regexp to hang!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 会耗费大量时间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("有些正则引擎能够处理好这种查询，但大多数引擎对此都无能为力。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h2",{attrs:{id:"简化的例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简化的例子","aria-hidden":"true"}},[s._v("#")]),s._v(" 简化的例子")]),s._v(" "),a("p",[s._v("问题在哪？为何正则表达式会「挂起」？")]),s._v(" "),a("p",[s._v("为了理解它，我们来简化一下例子：移除空格符 "),a("code",{staticClass:"pattern"},[s._v("\\s?")]),s._v("，使其成为 "),a("code",{staticClass:"pattern"},[s._v("^(\\w+)*$")]),s._v("。")]),s._v(" "),a("p",[s._v("同时为了让问题更显著，再用 "),a("code",{staticClass:"pattern"},[s._v("\\d")]),s._v(" 替换掉 "),a("code",{staticClass:"pattern"},[s._v("\\w")]),s._v("。这个新的正则表达式执行时仍然会挂起，比如：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^(\\d+)*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"012345678901234567890123456789!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 会耗费大量时间")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("所以正则到底哪里出了问题？")]),s._v(" "),a("br"),s._v(" "),a("p",[s._v("首先，有人可能发现了这个正则 "),a("code",{staticClass:"pattern"},[s._v("(\\d+)*")]),s._v(" 有点奇怪，量词 "),a("code",{staticClass:"pattern"},[s._v("*")]),s._v(" 有点画蛇添足。如果我们要匹配数字，那我们可以使用 "),a("code",{staticClass:"pattern"},[s._v("\\d+")])]),s._v(" "),a("p",[s._v("实际上，正则表达式是非常死板、机械化的。造成它运行缓慢的原因和上面我们看到的那样，所以让我们来理解它运作过程，然后问题的原因就会显而易见了。")]),s._v(" "),a("p",[s._v("在 "),a("code",{staticClass:"subject"},[s._v("123456789!")]),s._v(" 这行中（这里简写了，看得更清晰一些）中查询 "),a("code",{staticClass:"pattern"},[s._v("^(\\d+)*$")]),s._v(" 时到底发生了什么，要耗时这么久呢？")]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("首先，正则引擎尝试查一个数字 "),a("code",{staticClass:"pattern"},[s._v("\\d+")]),s._v("。加号 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 默认为贪婪模式，所以它囊括/消耗（consume）了所有数字：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\d+.......\n(123456789)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("然后它尝试应用星号量词，但是此时已经没有更多数字了，所以星号匹配不到任何东西。")]),s._v(" "),a("p",[s._v("模式中接下来的 "),a("code",{staticClass:"pattern"},[s._v("$")]),s._v(" 匹配字符串的结束，但是我们例子的文字中有 "),a("code",{staticClass:"subject"},[s._v("!")]),s._v("，所以匹配失败，没有匹配结果：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("           X\n\\d+........$\n(123456789)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("由于没有匹配结果，贪婪量词 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 的重复匹配次数会减一，并往前回溯一个字符。")])]),s._v(" "),a("p",[s._v("现在 "),a("code",{staticClass:"pattern"},[s._v("\\d+")]),s._v(" 会匹配除了最后一个数字之外的所有数字：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\d+.......\n(12345678)9!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[s._v("然后引擎尝试从新位置 ("),a("code",[s._v("9")]),s._v(") 继续搜索。")])]),s._v(" "),a("p",[s._v("星号 "),a("code",{staticClass:"pattern"},[s._v("(\\d+)*")]),s._v(" 可以成功应用 – 它匹配到了数字 "),a("code",{staticClass:"match"},[s._v("9")]),s._v(" ：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\d+.......\\d+\n(12345678)(9)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("引擎再次去尝试匹配 "),a("code",{staticClass:"pattern"},[s._v("$")]),s._v("，但是失败了，因为它遇到了 "),a("code",{staticClass:"subject"},[s._v("!")]),s._v("：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("             X\n\\d+.......\\d+\n(12345678)(9)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[s._v("没有匹配结果，所以引擎继续回溯，减少重复匹配次数。回溯的运行过程基本上是这样的：最后一个贪婪量词逐渐减少重复匹配次数，然后前一个贪婪量词再减少重复匹配次数，以此类推。")])])])]),s._v(" "),a("p",[s._v("它会尝试所有可能的排列组合，这里是他们的例子：")]),s._v(" "),a("p",[s._v("第一串数字 "),a("code",{staticClass:"pattern"},[s._v("\\d+")]),s._v(" 有 7 位数，后面跟着一串 2 位数的数字：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("             X\n\\d+......\\d+\n(1234567)(89)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("第一串数字有 7 位数，后面跟着两串数字，每串数字各有 1 位数：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("               X\n\\d+......\\d+\\d+\n(1234567)(8)(9)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("第一串数字有 6 位数，后面跟着一串 3 位数的数字：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("             X\n\\d+.......\\d+\n(123456)(789)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("第一串数字有 6 位数，后面跟着两串数字：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("               X\n\\d+.....\\d+ \\d+\n(123456)(78)(9)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("……以此类推。")]),s._v(" "),a("p",[s._v("像 "),a("code",[s._v("123456789")]),s._v(" 这样一串数字，分割成多个数的话有好几种分割方式。准确的说，如果这数字长度是 "),a("code",[s._v("n")]),s._v(" ，则共有 "),a("code",[s._v("2n-1")]),s._v(" 种方式去分割它。")]),s._v(" "),a("p",[s._v("假设 "),a("code",[s._v("n=20")]),s._v("，那么就有差不多一百万种排列组合，假设 "),a("code",[s._v("n=30")]),s._v("，那就得再乘上一千倍。正因为要尝试每种排列组合，所以才导致会消耗这么多时间。")]),s._v(" "),a("p",[s._v("那我们该怎么办？")]),s._v(" "),a("p",[s._v("我们应转而使用懒惰模式吗？")]),s._v(" "),a("p",[s._v("不幸的是，这没用：如果我们用 "),a("code",{staticClass:"pattern"},[s._v("\\d+?")]),s._v(" 去替代 "),a("code",{staticClass:"pattern"},[s._v("\\d+")]),s._v("，它还是会挂起。排列组合的顺序会变化，但是总数不变。")]),s._v(" "),a("p",[s._v("有些正则表达式引擎应经过严密的测试，并自带一种能够避免遍历所有排列组合的有限自动机来优化速度。但并不是所有引擎能够做到，也不是在所有场合下都有效果。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h2",{attrs:{id:"回到字符和字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回到字符和字符串","aria-hidden":"true"}},[s._v("#")]),s._v(" 回到字符和字符串")]),s._v(" "),a("p",[s._v("在我们第一个例子中，当我们用 "),a("code",{staticClass:"pattern"},[s._v("^(\\w+\\s?)*$")]),s._v(" 这种模式在字符串 "),a("code",{staticClass:"subject"},[s._v("An input that hangs!")]),s._v(" 中查找字符时，也遇到了相同的问题。")]),s._v(" "),a("p",[s._v("原因是 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 可以用来表示一个或多个字符：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("(input)\n(inpu)(t)\n(inp)(u)(t)\n(in)(p)(ut)\n...\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("对于我们人类来说，很显然它们无法匹配成功，因为例子中的字符串以感叹号 "),a("code",[s._v("!")]),s._v(" 结尾，然而正则表达式期望在末尾有一个词语式字符 "),a("code",{staticClass:"pattern"},[s._v("\\w")]),s._v(" 或者空格 "),a("code",{staticClass:"pattern"},[s._v("\\s")]),s._v(" 来结尾。正则引擎理解不了这种状况。")]),s._v(" "),a("p",[s._v("它尝试了所有 "),a("code",{staticClass:"pattern"},[s._v("(\\w+\\s?)*")]),s._v(" 的排列组合试图去囊括整个字符串，包含了带空格 "),a("code",{staticClass:"pattern"},[s._v("(\\w+\\s)*")]),s._v(" 的情形和不带空格 "),a("code",{staticClass:"pattern"},[s._v("(\\w+)*")]),s._v(" 的情形（因为 "),a("code",{staticClass:"pattern"},[s._v("\\s?")]),s._v(" 是可选的）。由于各种排列组合的数量太多了，所以耗费了大量时间去查询。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h2",{attrs:{id:"如何解决问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决问题？","aria-hidden":"true"}},[s._v("#")]),s._v(" 如何解决问题？")]),s._v(" "),a("p",[s._v("主要有 2 种解决方法。")]),s._v(" "),a("p",[s._v("第一种去试着减少各种排列组合的数量。")]),s._v(" "),a("p",[s._v("我们用把正则重写成 "),a("code",{staticClass:"pattern"},[s._v("^(\\w+\\s)*\\w*")]),s._v(" – 此处我们会查找后面跟着一个空格的、任意数量的单字字符 "),a("code",{staticClass:"pattern"},[s._v("(\\w+\\s)*")]),s._v("，然后跟着一个（可选的）单字字符 "),a("code",{staticClass:"pattern"},[s._v("\\w*")]),s._v("。")]),s._v(" "),a("p",[s._v("这个正则表达式在查询效果上等同于之前那个（查找的内容是相同的），运行起来也没问题：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^(\\w+\\s)*\\w*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"An input string that takes a long time or even makes this regex to hang!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// false")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("为什么问题消失了？")]),s._v(" "),a("p",[s._v("现在星号 "),a("code",{staticClass:"pattern"},[s._v("*")]),s._v(" 跟在 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\s")]),s._v(" 后面，而不是 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\s?")]),s._v(" 后面。这意味着它无法匹配一个拥有多个连续单字字符串 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 的单词，也就省下了原本去尝试这些排列组合的时间。")]),s._v(" "),a("p",[s._v("举个例子，之前那个模式 "),a("code",{staticClass:"pattern"},[s._v("(\\w+\\s?)*")]),s._v(" 可能以两个 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 的方式来匹配单词 "),a("code",{staticClass:"subject"},[s._v("string")]),s._v("：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\w+\\w+\nstring\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("之前那个模式，由于存在可选的 "),a("code",{staticClass:"pattern"},[s._v("\\s")]),s._v("，它允许 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v("、"),a("code",{staticClass:"pattern"},[s._v("\\w+\\s")]),s._v(" 和 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\w+")]),s._v(" 等等的变体形式。")]),s._v(" "),a("p",[s._v("我们重写之后的 "),a("code",{staticClass:"pattern"},[s._v("(\\w+\\s)*")]),s._v(" 就不存在这些情况：它可能会是 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\s")]),s._v(" 或者 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\s\\w+\\s")]),s._v("，但不可能是 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\w+")]),s._v("。所以总体上，排列组合的可能性大大减少了。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h2",{attrs:{id:"防止回溯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防止回溯","aria-hidden":"true"}},[s._v("#")]),s._v(" 防止回溯")]),s._v(" "),a("p",[s._v("有时候重写正则会比较麻烦，而且要推敲如何重写正则恐怕也并非易事。")]),s._v(" "),a("p",[s._v("另一种思路是禁止量词的回溯。")]),s._v(" "),a("p",[s._v("有些正则表达式我们人眼一看就知道无法匹配成功，但正则引擎还是会硬去尝试很多它的排列组合。")]),s._v(" "),a("p",[s._v("比如，正则 "),a("code",{staticClass:"pattern"},[s._v("(\\d+)*$")]),s._v(" 中 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 对于我们人类来说很明显不应去回溯，就算我们用两个独立的 "),a("code",{staticClass:"pattern"},[s._v("\\d+\\d+")]),s._v(" 去替换一个 "),a("code",{staticClass:"pattern"},[s._v("\\d+")]),s._v("，也是根本没作用的：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\\d+........\n(123456789)!\n\n\\d+...\\d+....\n(1234)(56789)!\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("原先的那个例子 "),a("code",{staticClass:"pattern"},[s._v("^(\\w+\\s?)*$")]),s._v(" 中我们可能希望禁止在 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 这里去进行回溯。逻辑是： "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 应当尽可能多地去匹配一个完整的单词。在 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 这里减少重复次数，然后将之进行分割，形成 "),a("code",{staticClass:"pattern"},[s._v("\\w+\\w+")]),s._v("，这类的做法没有任何意义。")]),s._v(" "),a("p",[s._v("为此，现代正则表达式引擎支持占有型量词（Possessive Quantifiers）。它们就像贪婪量词一样，但是不会进行回溯（所以比一般的正则量词更简单）。")]),s._v(" "),a("p",[s._v("它们也被成为“原子捕获分组（atomic capturing groups）” – 能够在括号内禁止回溯。")]),s._v(" "),a("p",[s._v("不幸的是，JavaScript 并不支持它，但是仍有其他办法。")]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("h3",{attrs:{id:"用前瞻视角解决问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用前瞻视角解决问题","aria-hidden":"true"}},[s._v("#")]),s._v(" 用前瞻视角解决问题")]),s._v(" "),a("p",[s._v("我们可以使用前瞻断言来防止回溯。")]),s._v(" "),a("p",[s._v("在不进行回溯的前提下，我们用 "),a("code",{staticClass:"pattern"},[s._v("(?=(\\w+))\\1")]),s._v(" 这个模式就可以尽可能多地重复匹配 "),a("code",{staticClass:"pattern"},[s._v("\\w")]),s._v("：")]),s._v(" "),a("p",[s._v("来解读一下：")]),s._v(" "),a("ul",[a("li",[s._v("前瞻断言 "),a("code",{staticClass:"pattern"},[s._v("?=")]),s._v(" 从当前位置开始，向前查找最长的单词 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v("。")]),s._v(" "),a("li",[s._v("引擎默认不会去记录 "),a("code",{staticClass:"pattern"},[s._v("?=...")]),s._v(" 括号中的内容。为了记录它们，所以我们把 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 放入括号中，这样引擎会记录括号中的内容了。")]),s._v(" "),a("li",[s._v("……然后用 "),a("code",{staticClass:"pattern"},[s._v("\\1")]),s._v(" 来引用括号中的内容。")])]),s._v(" "),a("p",[s._v("它的逻辑是：我们先进行前瞻查找 – 如果有符合 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 的单词，我们就可以用 "),a("code",{staticClass:"pattern"},[s._v("\\1")]),s._v(" 来匹配。")]),s._v(" "),a("p",[s._v("为什么？因为前瞻断言查找到一个单词 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v("，将其作为一个整体，然后进行捕获形成 "),a("code",{staticClass:"pattern"},[s._v("\\1")]),s._v(" 。所以我们最终实现了一种占有型加号 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 量词。它只将 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 作为一个整体来捕获，而不会只捕获它的某一部分。")]),s._v(" "),a("br"),s._v(" "),a("p",[s._v("例如，在单词 "),a("code",{staticClass:"subject"},[s._v("JavaScript")]),s._v(" 中不仅可以匹配 "),a("code",{staticClass:"match"},[s._v("Java")]),s._v("，而且可以忽略 "),a("code",{staticClass:"match"},[s._v("Script")]),s._v(" ，匹配模式的其余部分。")]),s._v(" "),a("p",[s._v("下面是 2 个模式的对比：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"JavaScript"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/\\w+Script/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// JavaScript")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"JavaScript"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/(?=(\\w+))\\1Script/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// null")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ol",[a("li",[s._v("第一个变体 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 首先捕获整个 "),a("code",{staticClass:"subject"},[s._v("JavaScript")]),s._v(" 单词，然而接下来 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 会一个字一个字地进行回溯，试图匹配整个模式的其余部分，直到 "),a("code",{staticClass:"pattern"},[s._v("\\w+")]),s._v(" 匹配到了 "),a("code",{staticClass:"match"},[s._v("Java")]),s._v(" 时，它最终才匹配成功。")]),s._v(" "),a("li",[s._v("第二个变体 "),a("code",{staticClass:"pattern"},[s._v("(?=(\\w+))")]),s._v(" 前瞻查找并匹配整个单词 "),a("code",{staticClass:"subject"},[s._v("JavaScript")]),s._v("，然后把整个单词作为一个整体包含进 "),a("code",{staticClass:"pattern"},[s._v("\\1")]),s._v(" 中，所以在它后面就无法查找到 "),a("code",{staticClass:"subject"},[s._v("Script")]),s._v(" 了。")])]),s._v(" "),a("p",[s._v("当我们需要禁止 "),a("code",{staticClass:"pattern"},[s._v("+")]),s._v(" 进行回溯的话，我们只要把 "),a("code",{staticClass:"pattern"},[s._v("(?=(\\w+))\\1")]),s._v(" 中的 "),a("code",{staticClass:"pattern"},[s._v("\\w")]),s._v(" 替换成更复杂的正则表达式就能实现了。")]),s._v(" "),a("br"),s._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",[a("strong",[s._v("请注意：")])]),s._v(" "),a("p",[s._v("这些文章中有更多关于占有型量词和前瞻断言的的内容："),a("a",{attrs:{href:"http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead",target:"_blank",rel:"noopener noreferrer"}},[s._v("Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead"),a("OutboundLink")],1),s._v(" 和 "),a("a",{attrs:{href:"http://blog.stevenlevithan.com/archives/mimic-atomic-groups",target:"_blank",rel:"noopener noreferrer"}},[s._v("Mimicking Atomic Groups"),a("OutboundLink")],1),s._v("。")])]),s._v(" "),a("br"),s._v(" "),a("p",[s._v("我们现在用前瞻断言重写第一个例子中的正则来防止回溯吧：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^((?=(\\w+))\\2\\s?)*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"A good string"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// true")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"An input string that takes a long time or even makes this regex to hang!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// false，执行得很快！")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("这里我们用 "),a("code",{staticClass:"pattern"},[s._v("\\2")]),s._v(" 代替 "),a("code",{staticClass:"pattern"},[s._v("\\1")]),s._v("，因为这里附加了额外的外部括号。为了防止数字产生混淆，我们可以给括号命名，例如 "),a("code",{staticClass:"pattern"},[s._v("(?<word>\\w+)")]),s._v("。")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 括号被命名为 ?<word>，使用 \\k<word> 来引用")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" regexp "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[s._v("/^((?=(?<word>\\w+))\\k<word>\\s?)*$/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" str "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"An input string that takes a long time or even makes this regex to hang!"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// false")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("alert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" regexp"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("test")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"A correct string"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// true")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("br"),s._v(" "),a("p",[s._v("本文所描述的问题称作“灾难性回溯（catastrophic backtracking）”，又译作“回溯陷阱”。")]),s._v(" "),a("p",[s._v("我们有 2 种处理它的思路：")]),s._v(" "),a("ul",[a("li",[s._v("重写正则表达式，尽可能减少其中排列组合的数量。")]),s._v(" "),a("li",[s._v("防止回溯。")])]),s._v(" "),a("br"),s._v(" "),a("br"),s._v(" "),a("br")])},[],!1,null,null,null);t.default=e.exports}}]);